<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"></head><body><pre>From: XXXXX <xxxxxxxxxxxxx@hotmail.com>
To: zephyr@howdyneighbor.com
Subject: MS Interview Questions.

Hi,
	Your web-page about the Microsoft Interview was very much useful to me.
Thank u very much for that.

	I had a telephonic Interview last week with Microsoft. I didnt expect
such a simple interview from Microsoft. In spite of the Interview being
simple, I made few blunders. But, to my surprise, they informed me
coupla days ago that they wanted to interview again on this week. I have
no idea is it going to be the second level of the interview or else? 

	If you have any idea regarding this and the kind of questions that'd be
asked, will u please email me at XXXXXXXXXXX@hotmail.com ?

	I am herewith sending the questions asked to me. Hope u'll find it
useful!!!

	Please respond this mail ASAP.

Bye
XXXXXXXX

The Interview was 3 phased in C, C++ and Windows Prog. Some of my
answers may not be convincing to u. If so, please reply me what do u
feel as the correct answer.

Q : What is Operator, Operand, Expression, Statement in 'C' ?

A : Operators are symbols which take one or two or three operands or
    expressions and performs arithmetic or logical computations.
    There are three type of operators in 'C', they are: unary operators
    binary operators and trenary operators.

    Operands are variables or expressions which are used as parameters
for
    the operators to evaluate the expression.

    Expressions can be a combination of operands and operator in a legal
    structure.

    Statements are combination of expressions and keywords.

Q : Given
    int a=1, b=2, c=3; what does the following expressions evaluate to?

A : a &lt; b will evaluate to TRUE

    a &lt; b &amp;&amp; c &lt; b will evaluate to FALSE

    a &lt;= c or ?  will evaluate to TRUE

    (a+=3) &lt; c will evaluate to FALSE

Q : Given int n, i=10, j=20, x=3, y = 100;
    what is the value of n and y at the end of each of the foll.
expression.

A : a) n = (i &gt; j) &amp;&amp; (x &lt; ++y);

    after the expr. the values of n and y will be

    n = 0 and y = 100. y will not be incremented since the first
expression
    itself evaluates to FALSE. A FALSE anded with any expression is
FALSE.
    So, the second expression will not be evaluated

    b) n = (j - i) &amp;&amp; (x &lt; y++);

    the result n = 1 and y = 101

    c) n = (i &lt; j) || (y+=i);

    the result n = 1 and y = 100

    d) I am afraid I did not note down the 4th expression.

Q :  int x = 5;
     int y = 7;
     what is the value of x and y after the expression y+=x++;

A : x = 6 and y = 12

Q : if the expression is y+=++x;, what is the the value of y?

A : y will be 13 in this case

Q : How do you multiply a variable by 16 without using the
multiplication
    operator '*'.

A : We can use bitwise shift operator to achieve the result. Supposing x
is
    a int variable to be multiplied by 16. We can have the expression

    x &lt;&lt;= 4; to achive the result.

Q : What if you have to multiply by 15?

A : We can bitwise left shift the variable by 4 times and subtract 16
from
    the resul.

Q : Convert 27 to Hexadecimal notation

A : 1B

Q : Explain the following declaration : long foo(char);

A : it's a function declaration to notify the compiler that foo is a
    function which takes a char parameter and returns a long variable.

Q : write a function declaration for a function which returns int * and
    takes float, int and char * as parameters

A : int * func(float, int, char*)

Q : what is the function prototype of printf() in 'C' and what does it
return

A : int printf(char *, ...);
    it returns the no. of bytes printed. Here ... means it takes
variable
    no. of parameters

Q : int (*a) [10];
    a++;
    What is the value of a after this?

A : a will be incremented by 20, assuming the size of int is 2.

Q : main()
    {
        int *ptr;
        *ptr=10;
     }
     what is wrong with this?

A : it will raise an error. Because, ptr does not point to any memory
location
    so assigning a value to it will result in error.

Q : typedefine a function pointer which takes a int and float as
parameter
    and returns a float *.

A : typedef float* (*fp) (int, float);

Q : which of the foll. expression will affect the values of pa or pb

A : a) pb - pa;
    does not affect pa or pb

    b) ++pa;
    affects pa

    c) pa + i
    does not affect pa or pb

    d) pa &lt; pb
    does not affect pa or pb

Q : Is the following operation illegal? assume pa and pb as pointers

A : a) pa * pb
    illegal

    b) pa + pb
    illegal

    c) pa - pb
    legal

    d) pa &lt;&lt; pb
    illegal


        Then various questions were asked in C++ and Windows
programming.

        I did not take a note of it.

some of them include

what is the advantage of OOP?
what is polymorphism?
the diff. among struct, class and union?
recursive function mechanism
virtual classes and virtual functions


how does Windows prog. differs from DOS prog.
what is the advantage of Windows
what does winmain and wndproc do?
how does user input are trapped in Windows?
Windows Messaging mechanism
....... ETC....


The following is the questionire which they sent me to be used while
interviewing. But, no questions were asked from this.

Q:      #include <stdio.h>

        void main(void)
        {
                char array1[6] = {"squid"};
                char array2[6] = {"llama"};

                char *ptr1 = array1;
                char *ptr2 = array2;

                printf("*ptr1 = %s\t*ptr2 = %s\n\n", ptr1, ptr2);

                swap(&amp;ptr1, &amp;ptr2);

                printf("*ptr1 = %s\t*ptr2 = %s\n\n", ptr1, ptr2);
        }

A : The question is not given for this problem. Assuming, I am asked to
find out
the output of the program. The first printf would print

        *ptr1 = squid   *ptr2 = llama

    The second printf functions output cannot be determined unless we
know
    what is done inside the swap(). The swap function takes a pointer to
pointer
    parameter

Q :  What is the output of the following program? How can the code be 
changed to give the    expected output?

                #include <stdio.h>

                #define ONE             1
                #define TWO             2
                #define NEG1    ONE - TWO
                #define THREE   TWO - NEG1
        
                void main( void )
                {
                        printf( "ONE = %d\n", ONE );
                        printf( "TWO = %d\n", TWO );
                        printf( "THREE = %d\n", THREE );
                }

A : The output is

                        ONE = 1
                        TWO =  2
                        THREE = -1
    We have to change the the third macro to

    #define THREE   TWO - (NEG1)
    to get the desired output
    


Q : 

#include <stdio.h>
#include <stdlib.h>

void main(int, char *[]);
void foo(int);

void main(int argc, char *argv[])
{
        int x;

        x = atoi(argv[1]);
        foo(x);
}

void foo(int x)
{
        int count=0;

        while (x)
                x &amp;= (x-1), count++;
        printf ("count = %1d\n", count);
}


Command-line to execute program:

&gt;test 5


A : the output is

        count = 2


Q : Is there anything wrong with the following code?  If so, how would
you
fix it?

class X
{
protected:
  int a;
public:
  X(int n) { a = n; }
};

void somefunction()
{
  X* pX = new X[12];
}


A : Yes, it does not have the default constructor. I can add the
constructor

    X::X() {}
    to the class to fix it


Q : Given:

class String
{
        int length;
        char * buffer;
public:
        String();
        String(const char *s);
        ~String();
};

        Write the copy constructor for this class.


A : String :: String ( const String &amp;s)
    {
        length = s.length;
        buffer = new char[length];
        strcpy(buffer, s.buffer);
     }


Q : What is the output of the printf statement in the following code
snippet
if it is compiled as part of a C program?  What if it's part of a C++ 
program?

void f()
{
        int x;
        x = 5;
        g(x);
        printf("x = %d\n", x);
}


A : if it's a 'C' program, the printf function will always print x = 5

    if it's a 'C++' program, there's a possibility that the g(x)
function
    takes x as a reference and change the value of x. So, the x value
may
    differ in the printf function


Q : Read and explain the following code:

class X
{
        int n;
        char *pChar;
public:
        X();
        X(int a = 0);
};

void f()
{
        X x;
        x.n = 4;
}


A : it has 2 errors. The constructors will lead to ambiguity. And x.n is
not
    accessible because n is private member data.


Q : Implement a constructor for this class which initializes the member
variable n with the value passed as a.


A : x(int a){ n = a;}


Q : How would you initialize n with a  if n were declared const?


A : x(int a) : n(a) { }


Q : If n is a static, non-const member of class X, how would you
initialize 
it?


A : int X :: n = 10;


Q : Assuming that the constructor also allocates memory for pChar, what
problems might arise from using this class? How would you eliminate
these 
problems?


A : When the object is destroyed, the memory allocated for that does not
    get released. So, we can write a destructor as

    X :: ~X() { delete[] pChar;}


Q : What is the output from this program?

#include <iostream.h>

class Base
{
  public:
    Base() { vf(); }
    ~Base() { vf(); }
    virtual void vf() { cout &lt;&lt; "Base::vf()" &lt;&lt; endl; }
};

class Derived : public Base
{
  public:
    Derived() { };
    ~Derived() { };
    virtual void vf() { cout &lt;&lt; "Derived::vf()" &lt;&lt; endl; }
};

void main()
{
  Base* pb = new Derived;

  pb-&gt;vf();
  
  delete pb;
}


A : the output is

        Base::vf()
        Derived::vf()
        Base::vf()



Q : What problems if any do you see in the following code fragment? 
(Assume
that X is some user-defined class and that E is some user-defined class 
used to encapsulate the details of  error conditions.  GetChunk is some 
utility function which should normally return a non-NULL pointer.)


void f()
{
  try
  {
    g();
  }
  catch(E e)
  {
                cerr &lt;&lt; e.text &lt;&lt; endl;
  }
}

void g()
{
  X* pX = new X;
  h(pX);
  delete pX;
}

void h(X* pX)
{
  // ...

        if( GetChunk() == NULL )
                throw E("No chunk available");
  // ...
}


A : No problem is perceived


Q : What is the output of the following program?

#include <iostream.h>

void main()
{
        int i = 5;
        int j = 4;
        int&amp; r1 = i;
        int&amp; r2 = j;
        int* p1 = &amp;r1;
        int* p2 = &amp;r2;
        *p1 = 3;
        *p2 = 2;
        cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;
        cout &lt;&lt; "j = " &lt;&lt; j &lt;&lt; endl;
        r1 = r2;
        p2 = &amp;r1;
        *p2 = 1;
        cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;
        cout &lt;&lt; "j = " &lt;&lt; j &lt;&lt; endl;
}


A  : the output is

i = 3
j = 2
i = 1
j = 2


Q : What's the output of the following program?

#include <iostream.h>

class X
{
public:
  X(char* s) { cout &lt;&lt; s &lt;&lt; endl; }
};

class Y : public X
{
  X a;
  X b;
public:
  Y() : b("b"), a("a"), X("base") {}
};

void main()
{
  Y y;
}

A : the output is

base
a
b


Q : Will this work?

void X::SwitchMe(X* anotherX)
{
  this = anotherX;
}

A : it should not work.



Q : CODEGEN.C

        int globalint;

        void function(int i)
        {
                return i+1;
        }

        void main()
        {
                globalint = function(1);
        }

A : there will be a compile time error for this program. Because the
return
value of function is void which cannot be assigned to globalint.


GENERIC.C

#include "windows.h"
#include "generic.h"

HANDLE hInst;

int PASCAL WinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
HANDLE hInstance;
HANDLE hPrevInstance;
LPSTR lpCmdLine;
int nCmdShow;
{
    MSG msg;

    if (!hPrevInstance)
        if (!InitApplication(hInstance))
            return (FALSE);

if (!InitInstance(hInstance, nCmdShow))
        return (FALSE);

while (GetMessage(&amp;msg,
            NULL,
            NULL,
            NULL))
        {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
    }
    return (msg.wParam);
}


BOOL InitApplication(hInstance)
HANDLE hInstance;
{
    WNDCLASS  wc;


    wc.style = NULL;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  "GenericMenu";
    wc.lpszClassName = "GenericWClass";

    return (RegisterClass(&amp;wc));

}




BOOL InitInstance(hInstance, nCmdShow)
    HANDLE          hInstance;
    int             nCmdShow;
{
    HWND            hWnd;

    hInst = hInstance;

    hWnd = CreateWindow(
        "GenericWClass",
        "Generic Sample Application",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        NULL
    );


    if (!hWnd)
        return (FALSE);


    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);
    return (TRUE);

}


long FAR PASCAL MainWndProc(hWnd, message, wParam, lParam)
HWND hWnd;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    FARPROC lpProcAbout;

    switch (message) {
        case WM_COMMAND:
            if (wParam == IDM_ABOUT) {
                  lpProcAbout = MakeProcInstance(About, hInst);

                  DialogBox(hInst,
                    "AboutBox",
                    hWnd,
                    lpProcAbout);

                  FreeProcInstance(lpProcAbout);
                  break;
            }
            else
           return(DefWindowProc(hWnd,message,wParam,lParam));
 
        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        default:
            return (DefWindowProc(hWnd,message, wParam, lParam));
    }
    return (NULL);
}




BOOL FAR PASCAL About(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
{
    switch (message) {
        case WM_INITDIALOG:
            return (TRUE);

        case WM_COMMAND:
            if (wParam == IDOK
                || wParam == IDCANCEL) {
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }
            break;
    }
    return (FALSE);
}

</iostream.h></iostream.h></iostream.h></stdlib.h></stdio.h></stdio.h></stdio.h></xxxxxxxxxxxxx@hotmail.com></pre>


</body></html>