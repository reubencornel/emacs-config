(def roman-conversions (hash-map "I" 1 "V" 5 "X" 10 "L" 50 "C" 100 "D" 500 "M" 1000 ))

(def rules (hash-map "V" "I"
		     "X" "I"
		     "L" "X"
		     "C" "X"
		     "D" "C"
		     "M" "C"))

(defn find-slightly-smaller-number[number largest-number]
  (or (get rules largest-number)
      ""))

(defn length [seq]
  (count seq))

(defn current-digit-is-greater-than-next[string]
  (> (get roman-conversions (subs string 1 2))
     (get roman-conversions (subs string 0 1))))

(defn decode-roman[string]
;  (prn string)
  (cond (= (length string) 1) (get roman-conversions string)
	:else (+ (if (current-digit-is-greater-than-next string)
		   (* -1 (get roman-conversions (subs string 0 1)))
		   (get roman-conversions (subs string 0 1)))
		 (decode-roman (subs string 1)))))

(defn sorted-roman-numerals[]
  (map first (sort-by (fn[x] (second x)) roman-conversions)))
	
(defn find-slightly-larger-number[number]
  ;; Loop through the array
  (loop [keys (map first (sort-by (fn[x] (second x)) roman-conversions))] 
  ;; If the roman representation is greater than number 
    (if (>=  (get roman-conversions (first keys)) number)
      (do 
	;;     ASSERTION: Roman represtnation > number 
	;;     then return the number
	(assert (>= (get roman-conversions (first keys)) number))
	(first keys))
      (if (= (count keys) 1)
	;; If we are end of the key list 
	(do 
	  ;;     ASSERTION: we are at the end of the list
	  (assert (= (count keys) 1))
	  ;;     then return the last number
	  (first keys))
	;; else
	(do 
	 ;;     ASSERTION the number is greater than the current roman reprenstation and there are elements in the list
	  (assert (and (> number (get roman-conversions (first keys))) 
		       (> (count keys) 1)))
	  ;;     Continue looping
	  (recur (rest keys)))))))
	   

(defn exact-match[number]
  ;; Simple
  ;; Loop till you find the exact match
  (loop [x (sorted-roman-numerals)
	 prev-number nil]
    (if (empty? x)
      prev-number
      (if (< number (get roman-conversions (first x)))
	prev-number
	(recur (rest x)
	       (first x))))))

(defn positive?[number]
  (>= number 0))

(defn better-than[number roman-number1 roman-number2]
  (if (not (positive? (- number (decode-roman roman-number2))))
    true
    (if (not (positive? (- number (decode-roman roman-number1))))
      false
      (if (<= (- number (decode-roman roman-number1))
	      (- number (decode-roman roman-number2)))
	true
	false))))
    
 
(defn find-best-roman-numeral[number]
  (let [largest-number (find-slightly-larger-number number)  ;; Find the number that is slightly larger than the current number
	smaller-number (find-slightly-smaller-number number largest-number)]  ;; find the number that is slightly smaller than the selected largest number
    (if (better-than number
		     (exact-match number)
		     (str smaller-number largest-number))
      (exact-match number)
      (str smaller-number largest-number))))

	
(defn encode-roman[number]
  (cond (= number 0) ""
	:else (let [roman-numeral (find-best-roman-numeral number)]
		(assert (> number 0))
		(str roman-numeral
		     (encode-roman (- number (decode-roman roman-numeral)))))))
		   
 