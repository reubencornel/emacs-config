<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>

<title>datastructures</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2009-09-02 15:44:43 EDT"/>
<meta name="author" content="Reuben Francis Cornel"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">datastructures</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Class 2 </a>
<ul>
<li><a href="#sec-1.1">1.1 Each logical sector is separted by 5 physical sector </a>
<ul>
<li><a href="#sec-1.1.1">1.1.1 Done because&hellip; </a></li>
</ul>
</li>
<li><a href="#sec-1.2">1.2 Modern disc support 1:1 interleave factor. </a></li>
<li><a href="#sec-1.3">1.3 Cluster</a></li>
<li><a href="#sec-1.4">1.4 Block Allocation</a>
<ul>
<li><a href="#sec-1.4.1">1.4.1 Disadvantages</a></li>
</ul>
</li>
<li><a href="#sec-1.5">1.5 Cost of a disc access</a>
<ul>
<li><a href="#sec-1.5.1">1.5.1 Seek: So that they sit ove the tracks they sit over the tracks,</a></li>
<li><a href="#sec-1.5.2">1.5.2 Rotation Cost: Time to spin track to the data location. on avg</a></li>
<li><a href="#sec-1.5.3">1.5.3 Transfer: Time to read the data off the disc</a></li>
<li><a href="#sec-1.5.4">1.5.4 EXAMPLE: 8MB file divided into 34256 byte records </a></li>
</ul>
</li>
<li><a href="#sec-1.6">1.6 Data from disc to application</a>
<ul>
<li><a href="#sec-1.6.1">1.6.1 Process </a></li>
</ul>
</li>
<li><a href="#sec-1.7">1.7 File Manager                                        :file-manager: </a></li>
<li><a href="#sec-1.8">1.8 IO Buffer</a></li>
<li><a href="#sec-1.9">1.9 IO Processor</a></li>
<li><a href="#sec-1.10">1.10 Disk controller</a></li>
</ul>
</li>
<li><a href="#sec-2">2 Class 3 </a>
<ul>
<li><a href="#sec-2.1">2.1 Buffer management </a>
<ul>
<li><a href="#sec-2.1.1">2.1.1 multiple buffers </a></li>
</ul>
</li>
<li><a href="#sec-2.2">2.2 Basic over view of a Unix kernel </a></li>
<li><a href="#sec-2.3">2.3 Journey of a byte (specifically with in UNIX) </a></li>
<li><a href="#sec-2.4">2.4 Logical file organization </a>
<ul>
<li><a href="#sec-2.4.1">2.4.1 Managing files of records </a></li>
<li><a href="#sec-2.4.2">2.4.2 Searching for records </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3">3 Class 4 </a>
<ul>
<li><a href="#sec-3.1">3.1 Sequential search </a>
<ul>
<li><a href="#sec-3.1.1">3.1.1 Perform record blocking for files to large </a></li>
<li><a href="#sec-3.1.2">3.1.2 Direct access: </a></li>
<li><a href="#sec-3.1.3">3.1.3 Possible improvements to sequential search </a></li>
</ul>
</li>
<li><a href="#sec-3.2">3.2 Binary </a></li>
</ul>
</li>
<li><a href="#sec-4">4 Class 5 </a>
<ul>
<li><a href="#sec-4.1">4.1 File management </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Class 2 </h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1.1" class="outline-3">
<h3 id="sec-1.1"><span class="section-number-3">1.1</span> Each logical sector is separted by 5 physical sector </h3>
<div class="outline-text-3" id="text-1.1">


</div>

<div id="outline-container-1.1.1" class="outline-4">
<h4 id="sec-1.1.1"><span class="section-number-4">1.1.1</span> Done because&hellip; </h4>
<div class="outline-text-4" id="text-1.1.1">

<p>to support processing time required after a sector is read
before the next read can occur.
</p></div>
</div>

</div>

<div id="outline-container-1.2" class="outline-3">
<h3 id="sec-1.2"><span class="section-number-3">1.2</span> Modern disc support 1:1 interleave factor. </h3>
<div class="outline-text-3" id="text-1.2">

</div>

</div>

<div id="outline-container-1.3" class="outline-3">
<h3 id="sec-1.3"><span class="section-number-3">1.3</span> Cluster &nbsp;&nbsp;&nbsp;<span class="tag"><span class="cluster">cluster</span></span></h3>
<div class="outline-text-3" id="text-1.3">

<p>OS File manager may require applications to bundle into an atomic
collection of sectors, called a cluster.
</p>
<p>
The file allocation table(FAT) binds the sectors to the
clusters.allows a cluster to be decomposed into a collection of
phsycial sector locations.
</p>
<p>
Note: bigger clusters imply fewer seeks but at cost of more wasted
space.
</p>
<p>
When disc started becoming big&hellip;the clusters started to
increase.
</p></div>

</div>

<div id="outline-container-1.4" class="outline-3">
<h3 id="sec-1.4"><span class="section-number-3">1.4</span> Block Allocation &nbsp;&nbsp;&nbsp;<span class="tag"><span class="block">block</span>&nbsp;<span class="allocation">allocation</span></span></h3>
<div class="outline-text-3" id="text-1.4">

<p>Rather than using clusters can allow the user to store data in
variable size blocks.
</p>
<p>
Allows us to avoid sector spanning or sector fragmentation.
</p>
<p>
sector fragementation&hellip;sectors fragmented
</p>
<p>
each block holds some integer number of logical records, this is
called blocking factor.
</p>
<p>
requires a count and/or key subblocks to be precede each block
</p>
<p>
count key block
</p>
<p>
count: defines the size of the block
key: fast key based lookup
</p>
<p>
fragmentation?
</p>
<p>
as with sectors increasing blocking factor can reduce non data over
head. But can also dramatically increase block fragmentation.
</p>

</div>

<div id="outline-container-1.4.1" class="outline-4">
<h4 id="sec-1.4.1"><span class="section-number-4">1.4.1</span> Disadvantages &nbsp;&nbsp;&nbsp;<span class="tag"><span class="disadvantages">disadvantages</span>&nbsp;<span class="block">block</span></span></h4>
<div class="outline-text-4" id="text-1.4.1">


<ul>
<li id="sec-1.4.1.1">blocking requires an application/os to manage data organization <br/>
on disc. For this to be useful is that everything either has to
be in the OS or completely by the application(which is
generally a bad idea)

</li>
<li id="sec-1.4.1.2">Bloocking does preclude the use of sync techniques, supported by <br/>
generic sector allocation.
</li>
<li id="sec-1.4.1.3">No production operating system support blocks <br/>

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-1.5" class="outline-3">
<h3 id="sec-1.5"><span class="section-number-3">1.5</span> Cost of a disc access &nbsp;&nbsp;&nbsp;<span class="tag"><span class="efficiency">efficiency</span>&nbsp;<span class="disk">disk</span>&nbsp;<span class="access">access</span></span></h3>
<div class="outline-text-3" id="text-1.5">



</div>

<div id="outline-container-1.5.1" class="outline-4">
<h4 id="sec-1.5.1"><span class="section-number-4">1.5.1</span> Seek: So that they sit ove the tracks they sit over the tracks, &nbsp;&nbsp;&nbsp;<span class="tag"><span class="seek">seek</span>&nbsp;<span class="time">time</span></span></h4>
<div class="outline-text-4" id="text-1.5.1">

<p>time rquired to move the head to the right track, on avg
1/3 total cylinders on the disc
</p>
</div>

</div>

<div id="outline-container-1.5.2" class="outline-4">
<h4 id="sec-1.5.2"><span class="section-number-4">1.5.2</span> Rotation Cost: Time to spin track to the data location. on avg &nbsp;&nbsp;&nbsp;<span class="tag"><span class="rotation">rotation</span>&nbsp;<span class="cost">cost</span></span></h4>
<div class="outline-text-4" id="text-1.5.2">

<p>1/2 revolution
</p>
</div>

</div>

<div id="outline-container-1.5.3" class="outline-4">
<h4 id="sec-1.5.3"><span class="section-number-4">1.5.3</span> Transfer: Time to read the data off the disc &nbsp;&nbsp;&nbsp;<span class="tag"><span class="transfer">transfer</span>&nbsp;<span class="cost">cost</span></span></h4>
<div class="outline-text-4" id="text-1.5.3">

<p>number of bytes read/number of bytes per track * rotation time
</p>
</div>

</div>

<div id="outline-container-1.5.4" class="outline-4">
<h4 id="sec-1.5.4"><span class="section-number-4">1.5.4</span> EXAMPLE: 8MB file divided into 34256 byte records </h4>
<div class="outline-text-4" id="text-1.5.4">

<p>4096 cluster holds
16 records
</p>
<p>
We need a seqiece of 2125 cluster occupying atleast 102 tracks
</p>
<p>
Note: Assuming that Cheetah hardrive with 170 512-byte sectors per
track, that is it can hold 21 clusters per track.
</p>
<ul>
<li id="sec-1.5.4.1">Best Case: In sequence <br/>
each track = 1 seek + 1 rotation delay
1 rotation = 8 + 3 + 6 (for 10K rpm)
= 17 msec

<p>
Can read 16 tracks per cylinders in one rotation
17 * (102/16) cylinders
= 108&hellip;. msec
</p>
</li>
<li id="sec-1.5.4.2">Worst Cast: Random <br/>
16 records / cluster = 1 seek + 1 rot delay + 1 read
= 8 + 3 + 0.28 (from 10K rpm disc with 21 clusters/track)
6msec / 21 c
2125 clusters each costing 11.28 msec, 2125 * 11.28 = 23&hellip;secs

</li>
<li id="sec-1.5.4.3">The point is that the ratios never change <br/>

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-1.6" class="outline-3">
<h3 id="sec-1.6"><span class="section-number-3">1.6</span> Data from disc to application &nbsp;&nbsp;&nbsp;<span class="tag"><span class="data">data</span>&nbsp;<span class="transfer">transfer</span></span></h3>
<div class="outline-text-3" id="text-1.6">

<p>Append a character 'p' at the end of a text file,
</p>
<p>
write(textfile, 'p', 1)
</p>
</div>

<div id="outline-container-1.6.1" class="outline-4">
<h4 id="sec-1.6.1"><span class="section-number-4">1.6.1</span> Process </h4>
<div class="outline-text-4" id="text-1.6.1">

<ul>
<li id="sec-1.6.1.1">application asks os to write to the next available position <br/>
in the text file

</li>
<li id="sec-1.6.1.2">OS Passes request to the file manager <br/>
</li>
<li id="sec-1.6.1.3">The file manager looks up textfile in somee internal info tables <br/>
to determine if file is open/available, access restrictions and
what physical file text file represents

</li>
<li id="sec-1.6.1.4">The file manager searches FAT for physical location of the sector <br/>
to hold character p

</li>
<li id="sec-1.6.1.5">File manager locates/loads last sector (cluster containing last sector) <br/>
into an IO buffer in RAM and writes P to the buffer

</li>
<li id="sec-1.6.1.6">File manager as the IO processor to flush the buffer to the <br/>
proper physical location

</li>
<li id="sec-1.6.1.7">IO processor formats buffer it waits for the disk, and buffers data in to <br/>
proper size chunks for the  disk

</li>
<li id="sec-1.6.1.8">IO processor sends data to the disk controller <br/>

</li>
<li id="sec-1.6.1.9">Disk controller seeks the heads waits for target sector to rotate <br/>
under the heads and writes data to disk bit by bit

<p>
NOTE the point is there should be some way to recover the writes
in case the system fails.
</p>
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-1.7" class="outline-3">
<h3 id="sec-1.7"><span class="section-number-3">1.7</span> File Manager                                        :file-manager: </h3>
<div class="outline-text-3" id="text-1.7">

<p>Component of the Os manages high level IO requests by applications
and maintains information about open files (keeps track of status,
acess restrictions, ownership), FAT, so on
</p>
</div>

</div>

<div id="outline-container-1.8" class="outline-3">
<h3 id="sec-1.8"><span class="section-number-3">1.8</span> IO Buffer &nbsp;&nbsp;&nbsp;<span class="tag"><span class="IO">IO</span>&nbsp;<span class="buffer">buffer</span></span></h3>
<div class="outline-text-3" id="text-1.8">

<p>Area of main memory used to buffer data being read from and
writteen to the disk.ppp
</p>
</div>

</div>

<div id="outline-container-1.9" class="outline-3">
<h3 id="sec-1.9"><span class="section-number-3">1.9</span> IO Processor &nbsp;&nbsp;&nbsp;<span class="tag"><span class="IO">IO</span>&nbsp;<span class="processor">processor</span></span></h3>
<div class="outline-text-3" id="text-1.9">

<p>Specialized device used to assemble and dis assemble groups of
bytes for moving to and from external storage devices, it frees the
CPU for other more complicated processing
</p>
</div>

</div>

<div id="outline-container-1.10" class="outline-3">
<h3 id="sec-1.10"><span class="section-number-3">1.10</span> Disk controller &nbsp;&nbsp;&nbsp;<span class="tag"><span class="disk">disk</span>&nbsp;<span class="controller">controller</span></span></h3>
<div class="outline-text-3" id="text-1.10">

<p>Specific to the hard drive is used to control physical
characteristics of the disk drive( like availability status, moving
heads, reading and writing data at the bit level)
</p></div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Class 3 <span class="timestamp-wrapper"> <span class="timestamp">2009-08-26 Wed</span></span> </h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1"><span class="section-number-3">2.1</span> Buffer management </h3>
<div class="outline-text-3" id="text-2.1">


</div>

<div id="outline-container-2.1.1" class="outline-4">
<h4 id="sec-2.1.1"><span class="section-number-4">2.1.1</span> multiple buffers </h4>
<div class="outline-text-4" id="text-2.1.1">

<p>Allows both the cpu and IO operations to  be performed
simultaneously. CPU is not IO bound. Buffer pool is managed with
some reasonable scheme
</p><ul>
<li id="sec-2.1.1.1">Locate Mode <br/>
avoid copying buffers by
<ol>
<li>
Allow file manager to access program memory directly, or
</li>
<li>
Have the file manager provide program with locations of
internal system buffers
</li>
</ol>
</li>
<li id="sec-2.1.1.2">Scatter/Gather IO <br/>
Allow an in coming block to be scattered among a collection of
buffers. Allow an out going block to be gathered from a collection
of out going buffers with out being explicitly reconstructed into
a single buffer.
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-2.2" class="outline-3">
<h3 id="sec-2.2"><span class="section-number-3">2.2</span> Basic over view of a Unix kernel </h3>
<div class="outline-text-3" id="text-2.2">

<p>Contains components to support file IO,
</p>
<p>
Process layer(User programs,  Libraries, Shells)
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>

<tbody>
<tr></tr>
</tbody>
</table>


<p>
Kernel
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>

<tbody>
<tr></tr>
</tbody>
</table>


<p>
IO Sytems
</p>
<p>
Block IO                    Character IO               Network IO
(rAndom access              (Terminals, Printers)      (sockets)
IO to independetn                                     (indirect communication over the network layer)
fixed size data blocks)
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left"></col>
</colgroup>
<tbody>
<tr><td></td></tr>
</tbody>
</table>

block device driver          Character Device driver   Network devive driver

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left"></col>
</colgroup>
<tbody>
<tr><td></td></tr>
</tbody>
</table>

disk                      Console, printer             Network


<p>
Kernel views all io operations as a sequuence of bytes no logical
view of a file.
</p></div>

</div>

<div id="outline-container-2.3" class="outline-3">
<h3 id="sec-2.3"><span class="section-number-3">2.3</span> Journey of a byte (specifically with in UNIX) </h3>
<div class="outline-text-3" id="text-2.3">

<p>write(fd, byte, 1);
</p>
<ol>
<li>
Kernel is invoked by the system call interface
</li>
<li>
Kernel Connects file descriptor, fd, to a file or device using
the follwoinh information
<ul>
<li>
File descriptor table: Associates each descriptor to an open
file mapping
</li>
<li>
Open file table contains an entry for every file, eg, read
write mode, current offset in the file, pointers to generic
functions etc. all generic info for the file
</li>
<li>
Index node (i-node table): Are permanent and are stored in
disk along with the file and in node contains infor on file
location on the disk, the owner access permissions, size, and FAT
</li>
<li>
Remaining steps (sector buffering, writing, ch, etc use above
four tables and proceed as previously described.

</li>
</ul>

<p>TRIVIA: A file is a name stored in a directory with a hard link,
to the corresponding file inode. The i node maintains a count of
hard links and when the count falls to zeros the file is deleted.
</p>
<p>
All block IO in unix is modelled around a disk view
point. Originally unix used 512 byte sectors with no concept of
clusters.
</p>
<p>
The file system itself is a collection of files directories and
inodes stored on disk, kernel IO system is separated from the
file system and is requesting and loading file system as
necessary. This means we can tune the file system with out
modifying the kernel.
</p></li>
</ol>
</div>

</div>

<div id="outline-container-2.4" class="outline-3">
<h3 id="sec-2.4"><span class="section-number-3">2.4</span> Logical file organization </h3>
<div class="outline-text-3" id="text-2.4">

<p>Field: is a single indivisible data item,
Array: Collection of fields, just like in any programming language
Records: Collection of fields, but they can be different.
</p>
<p>
Stream files are a stream of bytes representing one of more
equivalent records. obviously a file acna store anything but for
simplicity we assume a collection of equivalent records.
</p><ul>
<li>
Cannot simply write the data to a file directly if we do we
loose the logical field and record distinctions.
Eg: If we have a last name field and a first name
field. Question is where does the logical field start and end.
</li>
<li>
4 common methods to delimit fields
<ol>
<li>
Field delimiter
<ol>
<li>
Fixed length
</li>
<li>
Field meta data, size of the field
</li>
<li>
A keyword = value + delimiter

</li>
</ol>
</li>
</ol>
</li>
<li>
Draw backs of these methods
<ol>
<li>
of field delimiter: Extra space for delimiters, cannot use
the delimiter as a part of the text
</li>
<li>
Fixed length: Wasted space, cannot change the size of the field
</li>
<li>
Overhead to store field sizes
</li>
<li>
Lots of wasted space

</li>
</ol>
</li>
</ul>

<p>Records have similar storage/retrieval requirements, common methods
to delimit them
</p>
<ol>
<li>
Fixed length fields
</li>
<li>
Make records a fixed number of fields
</li>
<li>
Begin a record with a size
</li>
<li>
Can use an external index to track the start locations of each
record.
</li>
<li>
Field delimiter

</li>
</ol>

</div>

<div id="outline-container-2.4.1" class="outline-4">
<h4 id="sec-2.4.1"><span class="section-number-4">2.4.1</span> Managing files of records </h4>
<div class="outline-text-4" id="text-2.4.1">

<p>Assuming a file with identical records, assocaiate a key with each
record.
</p>
<p>
Primary key is a field or a collection of fields that uniquely
identify a record from all others.
</p>
<p>
We sometimes use a secondary key these do not identify a record
uniquely rather they divide records into groups with a common
secondary key. Normally its not a good idea to use any data field
for a primary key in particular. We cannot guarantee wont have the
same field value.
</p>
<p>
Moreover fields can be modified and if a primary field changes, it
could cause problems or any parts of the system linked to that
record by primary key.
</p>
<p>
Use non data system generated fields. eg SSN, student id.
</p>
</div>

</div>

<div id="outline-container-2.4.2" class="outline-4">
<h4 id="sec-2.4.2"><span class="section-number-4">2.4.2</span> Searching for records </h4>
<div class="outline-text-4" id="text-2.4.2">

<ul>
<li id="sec-2.4.2.1">Sequential <br/>
Read through the file in sequence from beginning to end. supports
sequential or linear search
Best Case O(1)
Worst case O(n)
Avg Case: When target exists O(1/2n) = O(n)
</li>
<li id="sec-2.4.2.2">Random <br/>
</li>
</ul>
</div>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Class 4 <span class="timestamp-wrapper"> <span class="timestamp">2009-08-31 Mon</span></span> </h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1"><span class="section-number-3">3.1</span> Sequential search </h3>
<div class="outline-text-3" id="text-3.1">

<p>we can improve performance dramtically by reducing seeks and reads
which are much more expensive than in memory comparison.
</p>
</div>

<div id="outline-container-3.1.1" class="outline-4">
<h4 id="sec-3.1.1"><span class="section-number-4">3.1.1</span> Perform record blocking for files to large </h4>
<div class="outline-text-4" id="text-3.1.1">

<p>read blocks of mem records, search discard, read the next block
</p>
<p>
This can potentially reduce number of seeks from n to n/m
</p>
<p>
Note: This only changes absolute amount of time to search, it does
not change search efficiency, which is O(n) for average and worst
case.
</p>
<p>
despite poor efficiency of linear search it is acceptable in
certain cases.
</p><ol>
<li>
Small file
</li>
<li>
First pass through non indexed file
</li>
<li>
Stream
</li>
<li>
File is very rarely searched.
</li>
<li>
Searching for patterns: regex grep
</li>
<li>
Secondary key search with many matches expected.


</li>
</ol>

<p>Key tradeoff here is
</p><ol>
<li>
Cost of searching vs cost of building and maintaining a file or
data structure to support more efficient search.

</li>
</ol>
</div>

</div>

<div id="outline-container-3.1.2" class="outline-4">
<h4 id="sec-3.1.2"><span class="section-number-4">3.1.2</span> Direct access: </h4>
<div class="outline-text-4" id="text-3.1.2">

<p>Here rather than reading through the file record by record or
block by block you would jump directly to the location int he file
that contains the target record.
</p>
<p>
Obvious assumption is that we know where the target record
resides. For example, an array supports direct access, where each
record is fixed lenght and index is used as the primary key.
</p>
<p>
To support direct access we normally need fixed length records or
an external record location index file. So even given the ability
to determine the start location of record i in a file how do we
know which record is the target record?
</p>
</div>

</div>

<div id="outline-container-3.1.3" class="outline-4">
<h4 id="sec-3.1.3"><span class="section-number-4">3.1.3</span> Possible improvements to sequential search </h4>
<div class="outline-text-4" id="text-3.1.3">

<ol>
<li>
Make sequential search self organizing to try to improve long
term performance
<ol>
<li>
<b>Move to front</b>: Each time we find a target record we move it
to the front of the file and Move all preceding entries
back.  This keeps common records near the front of the file.

<p>
<span style="text-decoration:underline;">Disadvantage</span>:Cost of moving all preceding records back on
position.
</p>
<p>
<i>Note</i>:Move to front is similar to a LRU algorithm.
</p>
</li>
<li>
<b>Transpose</b>: When you locate a target record you swap it with
the record that immediately precedes it.

<p>
Cost of reorganization is smaller than move to front
</p>
<p>
<span style="text-decoration:underline;">Disadvantage</span>: Records move slowly towards the front of the
file, but the algorithm is more stable, than move to front.
</p>
</li>
<li>
<b>Count</b>: associate access count with each record, when it is
located you increment the access  count and move it forward
past all other records with a lower count.

<p>
<span style="text-decoration:underline;">Disadvantage</span>: This requires extra space for the counts,
reorganization can be expensive.
</p>
</li>
</ol>
</li>
</ol>
</div>
</div>

</div>

<div id="outline-container-3.2" class="outline-3">
<h3 id="sec-3.2"><span class="section-number-3">3.2</span> Binary </h3>
<div class="outline-text-3" id="text-3.2">

<p>Direct access on fixed length records, if the key is sorted by
primary key we can use binary search to improve efficiency.
</p>
<p>
This requires fixed length positions to calculate where the record
starts.
</p>
<p>
<span style="text-decoration:underline;">Advantage</span>: Search is order O(lg n)
</p>
<p>
<span style="text-decoration:underline;">Disadvantages</span>:
a) File must be maintained in sorted order,otherwise this does not
work.
b) Records must be fixed lenght
c) Binary search requires more than one or two seeks for small files
</p>




</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Class 5 <span class="timestamp-wrapper"> <span class="timestamp">2009-09-02 Wed</span></span> </h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1"><span class="section-number-3">4.1</span> File management </h3>
<div class="outline-text-3" id="text-4.1">

<p>Files are not static. 
How do we do simple operations like. Since addition is simple, we
are really concerned with variable lenght record update and fixed
or variable length delete.
</p><ul>
<li>
Add
Put the record in the first available position in the file, or
append to the end if no suitable space is available.
</li>
<li>
Update
An update is a delete followed by an add, for variable lenght
update, <i>we are really only concerned with record deletion</i>.
</li>
<li>
Delete
<ol>
<li>
<b>Record deletion and storage compaction</b>: We can delete a
record, then either in teh future or immediately, compact the
file to reclaim space to occupy space occupied by deleted records.

<p>
How do we recognize deleted records? 
</p><ul>
<li>
Tag record with a deleted marker at the front of the
record, change the file processing operations to recognize
these records as deleted.

</li>
<li>
Delay compacting till convienent: when the user is finished
with the file, till there are enough records to perform
compacting. 

<p>
<span style="text-decoration:underline;">Advantage</span>: can reclaim space with one pass
</p></li>
</ul>

<p><span style="text-decoration:underline;">Disadvantage</span>: not good in parallel situations.
</p>
</li>
<li>
<b>Dynamic space reclamation</b>: 

<ul>
<li>
Fixed Length records: What if we want to dynamically reclaim
space, when we add new records to a file.
We need a way to
<ul>
<li>
Mark delete records
Mark records as deleted in the file.
</li>
<li>
Need a way to rapidly find space previously used by
deleted records so that that space can be reclaimed by new
records added to the file.

<p>
We will maintain a stack of deleted records, a stack of
space available to be reclaimed during addition of new
records. We need to keep an offset to the location of the
first deleted record in the file.
</p>
<p>
Maintain the stack as follows everytime we delete a
record, we will 
</p><ul>
<li>
store in the deleted record the current head of stack
</li>
</ul>

<p>offset(storing offset to the next delete record in the
fil)
</p><ul>
<li>
Update head of stack off set in the program to point
to the newly deleted record

</li>
</ul>
</li>
<li>
If a deleted record exists grab first record and resuse its
space and update the head of stack point. Append to the end
of the file if no new records exist.

</li>
</ul>
</li>
<li>
Variable length records: More complicated because we need to
<ul>
<li>
mark records as deleted
mark record as dirty
<ul>
<li>
need to maintain an availiablity list 
is the same as fixed lenght records, you must also
maintain size of each deleted record. No problem because
record size is normally already part of a variable record.
</li>
<li>
Find appropriate position for new record if it exists
<ul>
<li>
First fit: Search avail list sequentially for the first
deleted record "big enough" to hold the new record.
</li>
<li>
Best fit What if the deleted record is bigger than the
new record. Getting around the problem
<ul>
<li>
Compacting Same problems as mentioned previously
<ul>
<li>
Add space to avail list This causes external
fragmentation, unused space between records. End up
with lots of little blocks too small to hold any new
record.
</li>
<li>
Merge adjacent deleted blocks.  may be rare, worse
still the avail list is not maintained in order of
physical location of each available block. So the
operation is gonna be expensive.
</li>
<li>
Pad the new record to fit the deleted space. This
causes internal fragmentation, there's lots of
unused space inside a record. The entire purpose of
variable lenght records is to avoid this.
</li>
<li>
Try smarter placement strategy: Suppose we keep the
avail list ordered ascending by size, and then apply
first fit, then it becomes best fit. Cost more to
maintain avail list, to find a location for a new
record.

<p>
This will leave tiny blocks of avail space in the
avail list. Can cost more to find more to find
position for new records.
</p></li>
</ul>
</li>
</ul>
</li>
<li>
Worst fit Intead keep avail list in descending order. Now
we have worst fit. Although we must maintain avail
list, one look at the avail list will tell us if we
need to append a record or add it to a deleted block.
<span style="text-decoration:underline;">Advantages</span>: potentially splitting the largest
availble hole will leave behind a large enough piece to
the useful for some add.  

<p>
Recall the binary search for a file is significantly more
efficient but it requires the file to be maintained in
sorted order. Also requires fixed lenght records. Take
primary key for each record with its offset and sort
those and use that sorted list as a reference into the
file and maintain it as the file is added, updated
dleted
</p>
<p>
<span style="text-decoration:underline;">advantages</span>
</p><ul>
<li>
Key index is smaller than the file, may be possible
to hold the index in main memory.
</li>
<li>
Key index can have fixed lenght records, so it
supports binary search
</li>
<li>
Key index will be rearragned on changes in the file
but file itself is maintained in entry sequence and
never needs to be reorganized

<p>
So any pinned record, (pinned: a record whose offset
defines it) are safe
</p>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</div>
</div>
</div>
<div id="postamble">
<p class="author"> Author: Reuben Francis Cornel
<a href="mailto:reuben@nom19898a.nomadic.ncsu.edu">&lt;reuben@nom19898a.nomadic.ncsu.edu&gt;</a>
</p>
<p class="date"> Date: 2009-09-02 15:44:43 EDT</p>
<p class="creator">HTML generated by org-mode 6.29c in emacs 23</p>
</div>
</div>
</body>
</html>
