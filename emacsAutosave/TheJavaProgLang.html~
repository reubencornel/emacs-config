<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>The Java Programming Language - Ken Arnold, James Gosling, David Holmes</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2009/12/29 17:08:17"/>
<meta name="author" content="Reuben Francis Cornel"/>
<link rel="stylesheet" type="text/css" href="orgstyle.css" />
</head><body>
<h1 class="title">The Java Programming Language - Ken Arnold, James Gosling, David Holmes</h1>
<h2>Table of Contents</h2>
<ul>
<li><a href="#sec-1">1 The Java programming language - 2005 edition</a></li>
<li><a href="#sec-2">2 A quick tour</a>
<ul>
<li><a href="#sec-3">2.1 Getting started</a></li>
<li><a href="#sec-4">2.2 Variables</a></li>
<li><a href="#sec-5">2.3 Named constants</a></li>
<li><a href="#sec-6">2.4 Unicdode</a></li>
<li><a href="#sec-7">2.5 Flow of control</a></li>
<li><a href="#sec-8">2.6 Classes and objects</a>
<ul>
<li><a href="#sec-9">2.6.1 Creating objects</a></li>
<li><a href="#sec-10">2.6.2 Static or Class fields</a></li>
<li><a href="#sec-11">2.6.3 The garbage collector</a></li>
<li><a href="#sec-12">2.6.4 Methods and parameters</a></li>
<li><a href="#sec-13">2.6.5 Static or class methods</a></li>
<li><a href="#sec-14">2.6.6 Arrays</a></li>
<li><a href="#sec-15">2.6.7 String Objects</a>
<ul>
<li><a href="#sec-16">2.6.7.1 Formatting</a></li>
</ul>
</li>
<li><a href="#sec-17">2.6.8 Extending a class</a></li>
<li><a href="#sec-18">2.6.9 Interfaces</a></li>
<li><a href="#sec-19">2.6.10 Generic Types</a></li>
<li><a href="#sec-20">2.6.11 Exceptions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<h2><a name="sec-1">1 The Java programming language - 2005 edition</a></h2>


<h2><a name="sec-2">2 A quick tour</a></h2>


<h3><a name="sec-3">2.1 Getting started</a></h3>

<ul>
<li>
Ok I like this, the book starts of in a no nonsense way. It talks
about classes and objects.
<ul>
<li>
Classes: Are like blueprints from which more objects can be created
</li>
<li>
Objects are instances of classes
</li>
</ul></li>
<li>
A class consists of
<ul>
<li>
Methods: Represent methods that can manipulate the state of the object.
</li>
<li>
Fields: represent the state of the object
</li>
</ul></li>
<li>
The book then discusses the obligatory "Hello World" program.

</li>
</ul>
<h3><a name="sec-4">2.2 Variables</a></h3>

<ul>
<li>
The section starts up with a dicussion of a program fibonacci
numbers. The idea being to demonstrate the concept of local
variables and instance variables
</li>
<li>
Basic data types  of the language
<ul>
<li>
Byte  - 1 Byte
</li>
<li>
Boolean - <code>True</code> or <code>False</code>
</li>
<li>
Char  - 1 Byte
</li>
<li>
Short - 2 Bytes
</li>
<li>
Int   - 4 Bytes
</li>
<li>
Long  - 8 Bytes
</li>
<li>
Float - 4 Bytes
</li>
<li>
Double - 8 Bytes
</li>
</ul></li>
<li>
Local variables can be declared with out being initialized but
then the compiler will complain with you try to use them with out
initializing them. <b>So in short, always initialize your local variables</b>
</li>
<li>
A loop will always run till either the condition becomes false or
an exception occurs or it encounters a break statement.
</li>
</ul>
<h3><a name="sec-5">2.3 Named constants</a></h3>

<ul>
<li>
Constants are defined using the keywords <code>static final</code>
</li>
<li>
enums are a way to represent a set of associated values. They are
better than using a set of in
</li>
</ul>
<h3><a name="sec-6">2.4 Unicdode</a></h3>

<ul>
<li>
Java code can be written in unicode too
</li>
</ul>
<h3><a name="sec-7">2.5 Flow of control</a></h3>

<ul>
<li>
This section gives an overview of the most commonly used control
flow constructs like <code>if..else</code>, operators 
</li>
</ul>
<h3><a name="sec-8">2.6 Classes and objects</a></h3>

<ul>
<li>
Discusses the syntax behind the class declaration
</li>
</ul>
<h4><a name="sec-9">2.6.1 Creating objects</a></h4>

<ul>
<li>
Objects are created using the new keyword
</li>
<li>
Objects are allocated in the heap. When ever a variable appears
to point to an object it always points to its reference. A
variable containing a <code>null</code> reference does not point to anything.
</li>
<li>
So typically when people tell you to pass an object to a
function what you actually are doing is passing a copy of the reference.
</li>
<li>
Fields in classes are also known as local variables
</li>
<li>
When <code>new</code> is invoked on an object the the constructor of the
class is invoked. If we invoke new with out any arguments the
default argumentless constructor is invoked.
</li>
</ul>
<h4><a name="sec-10">2.6.2 Static or Class fields</a></h4>

<ul>
<li>
*Class variables*: are variables that are shared between all
instances of objects.
</li>
<li>
They are declared by naming a method <code>static</code>.
</li>
</ul>
<h4><a name="sec-11">2.6.3 The garbage collector</a></h4>

<ul>
<li>
The garbage collector runs in the background. When we stop
referencing a particular object, the garbage collector is able
to detect the object and free it off the heap.
</li>
<li>
Although you <b>cannot</b> force the garbage collector to run at a
time of your preference.
</li>
</ul>
<h4><a name="sec-12">2.6.4 Methods and parameters</a></h4>

<ul>
<li>
Instance variables are generally not readily available for
manipulation. Instead this ability is provided by
methods. This forms the basis of <b>data encapsulation</b>.
</li>
<li>
It discusses how a method can be called from an object.
</li>
<li>
 It discusses the <code>return</code> statement. The type of the value of
the return statement has to match the declared return type of
the function.
</li>
<li>
the <code>this</code> reference always points to the current reference.
</li>
</ul>
<h4><a name="sec-13">2.6.5 Static or class methods</a></h4>

<ul>
<li>
Methods that perform operations on the class itself are known as
<code>class methods</code> they can be declared using the <code>static</code> keyword.
</li>
<li>
There are two reasons why this would be required
<ul>
<li>
To group functions providing that are related to the same
class but it doesn't make sense to instaniate the class. For
example the <code>Math</code> class has a bunch of functions that are
common but it does not make sense instantiating the objects.
</li>
<li>
Static methods cannot access non static members of the class
</li>
</ul></li>
</ul>
<h4><a name="sec-14">2.6.6 Arrays</a></h4>

<ul>
<li>
Arrays are a collection of variables of the same type.
</li>
<li>
All array accesses in java are bound checked as a result they
throw <code>ArrayIndexOutOfBoundsException</code> in case of an invalid access.
</li>
<li>
An empty array is not the same a null. An <b>empty array</b> is <b>one       with zero elements</b>. 
</li>
</ul>
<h4><a name="sec-15">2.6.7 String Objects</a></h4>

<ul>
<li>
String objects can be created directly by wraping the string up
in double quotes
</li>
<li>
The string concatenation operator java is totally messed up
primarily because you can use =+= to concatenate string which is
somehow now right.
</li>
<li>
String objects are read-only or immutable. So that means that
when you use a =+= 
</li>
</ul>
<h5><a name="sec-16">2.6.7.1 Formatting</a></h5>

<ul>
<li>
Can be done using the <code>Formatter</code> class
</li>
<li>
The formatter class can insert the right separator because of
the %n 
</li>
</ul>
<h4><a name="sec-17">2.6.8 Extending a class</a></h4>

<ul>
<li>
Talks about inteheritance etc, nothing new if you know oo
</li>
<li>
All classes extend the Object class
</li>
<li>
There is basic type checking in the Java compiler, so we have to
be careful when assigning stuff around.
</li>
</ul>
<h4><a name="sec-18">2.6.9 Interfaces</a></h4>

<ul>
<li>
Essentially used to define objects that behave according to a
</li>
</ul>specified contract.
<ul>
<li>
Intefaces can define nested interfaces and classes too
</li>
<li>
<b>All members of an interface are explicitly or implicitly       public</b>.
<ul>
<li>
This makes sense cause the whole idea of an inteface is to
provide some sort of contract to the outside world.
</li>
</ul></li>
<li>
An interface can be extended using the <code>extends</code> keyword,
usually an interface extends another inteface
<i>Does it make sense for an interface to extend a class?</i>
Actually no, come to think of it, an interface is not meant to
provide an implementation, but if it were to extend a class, the
class would have an implementation which screws up the whole thing.



</li>
</ul>
<h4><a name="sec-19">2.6.10 Generic Types</a></h4>

<ul>
<li>
Generic types introduce type safety into code
</li>
<li>
They also reduce code duplication

</li>
</ul>
<h4><a name="sec-20">2.6.11 Exceptions</a></h4>

<ul>
<li>
If a method notices something out of place it can throw an exception
</li>
<li>
We have checked exceptions that force you to check for those
exceptions explicitly.
</li>
<li>
Exceptions are handled using the <code>try...catch...finally</code> blocks.
</li>
<li>
You can have just the <code>try..finally</code> block with out any catch blocks
</li>
<li>
A method <b>has</b> to declare if it is going to throw checked exceptions
</li>
<li>
Unchecked exceptions can be thrown with out the need to declare them.
</li>
<li>
All exceptions must subclass the Throwable class
</li>
<li>
It makes sense to represent exceptions as objects as they can
have error dectection code in them.
</li>
</ul>
<p class="author"> Author: Reuben Francis Cornel
<a href="mailto:reuben@odin.local">&lt;reuben@odin.local&gt;</a>
</p>
<p class="date"> Date: 2009/12/29 17:08:17</p>
</body>
</html>
