(declaim (optimize (speed 3) (safety 0)))

(defun sieve(list)
  (labels ((filter (list element)
	     (when (not (null element))
	       (cons element 
		     (remove-if #'(lambda(x)
				    (= (rem x element) 0))
				list))))
	   (sieve-helper(list &optional (count 0))
	     (cond ((>= count (length list)) list)
		   (t (sieve-helper (filter list (nth count list))
				    (+ 1 count))))))
    (sieve-helper list)))

(compile 'sieve)


(defun basicPrimes()
  (sieve (loop for i from 2 to 31622 collect i)))
(compile 'basicPrimes)

(defun sieve-two-lists(number-list prime-list max-num)
  (let ((count 0)
	(sqrt-max (sqrt max-num)))
    (loop for i in prime-list
       while (< (sqrt max-num) i)
	 
	 
       

;; (defun prime(n1 n2)
;;   (let ((min n1)
;; 	(max n2))
;;     (loop for i in (reverse (sieve (loop for i from 2 to max collect i)))
;;        do (if (and (<= i max)
;; 		   (>= i min))
;; 	      (format t "~a~%" i)))))

;; (compile 'prime)

(defun main()
  (length (basicPrimes)))
;;   (let ((n (read)))
;;     (loop for i from 1 to n
;; 	 do (prime (read) (read)))))

(compile 'main)

(main)