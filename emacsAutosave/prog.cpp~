#define ORDER 5
#define INTEL
#define WINDOWS
#define _M_Ix86
#ifdef WINDOWS
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif	/*  */

#include <conio.h>
#include <iostream>
#include <fstream>
#include <cstdio>
#include <time.h>
#include <string>
#include <cstdlib>
#include <queue>
#include <math.h>
#include <vector>
#include <ctime>

#ifndef WINDOWS
#include <sys/time.h>
#endif	/*  */

using std: :cout;

using std: :ifstream;

using std: :ios;

using std: :ofstream;

using namespace std;


double          sum = 0.0;

struct btree_node {
	
	
	int             n;
	               
	int             key[ORDER - 1];
	               
	long            child[ORDER];
	               
	                bool leaf;
	               
};


struct btree_node_temp {
	
	
	int             n;
	               
	int             key[ORDER];
	               
	long            child[ORDER + 1];
	               
	                bool leaf;
	               
};


struct level_node {
	
	
	struct btree_node *node;
	               
	int             level;
	               
	long            offset;
	               
	               
};


vector < long  >parents;

vector < int   >childnos;

long            root_offset = 0;

vector < long  >::iterator it;



int 
check_leaf(btree_node * node)
{
	
	
	int             count = 0;
	
		int             flag = 1;
	
		
		while (count < ORDER) {
		
			
			if (node->child[count] != -1) {
			
				flag = 0;
			
				break;
			
		} 
			count++;
		
	} 
		return flag;
	
} 
btree_node * allocate_root()
{
	
		
		btree_node * node = new btree_node;
	
		node->n = 0;
	
		for (long i = 0; i < ORDER - 1; i++) {
		
			node->key[i] = 0;
		
	} 
	/*
	 * for(long i=0;i<ORDER;i++){ node->child[i]=0; }
		 */ 
		node->leaf = false;
	
		return node;
	
} 
btree_node * allocate_node()
{
	
		
		btree_node * node = new btree_node;
	
		node->n = 0;
	
		
		for (long i = 0; i < ORDER; i++) {
		
			node->child[i] = -1;
		
	} 
		
		return node;
	
} 

void 
create_empty_btree()
{
	
	
	fstream fp;
	
		btree_node * node = allocate_root();
	
		node->n = 0;
	
		node->leaf = true;
	
		
	/*
	 *  for(long i=0;i<ORDER-1;i++){ node->key[i]=0; }
		 */ 
		
		for (long i = 0; i < ORDER; i++) {
		
			node->child[i] = -1;
		
	} 
		
		btree_node * buffer = node;
	
		
fp.open("btree.out", ios: : in | ios: : out | ios: :binary);
	
		fp.clear();
	
fp.seekp(root_offset, ios: :beg);
	
		
		int             i = 0;
	
		int             j;
	
		
		
		
		
		//Writing the node to the file 
		char           *n_value = new char[4];
	
		sprintf(n_value, "%d", node->n);
	
		fp.write(n_value, 4);
	
		
		char           *key_value = new char[4 * (ORDER - 1)];
	
		for (i = 0, j = 0; i < 4 * (ORDER - 1); i = i + 4, j++) {
		
			
			sprintf(key_value + i, "%d", node->key[j]);
		
	} 
		
		fp.write(key_value, 4 * (ORDER - 1));
	
		
		
		char           *child_value = new char[4 * ORDER];
	
		for (i = 0, j = 0; i < 4 * ORDER; i = i + 4, j++) {
		
			
			sprintf(child_value + i, "%ld", node->child[j]);
		
	} 
		
		fp.write(child_value, 4 * ORDER);
	
		
		cout << "Created an empty btree successfully";
	
		fp.close();
	
		delete node;
	
		
		
		
} 

long 
write_node(btree_node * node, long offset)
{
	
	
	fstream fp;
	
		//cout << "in the write_node function";
	
fp.open("btree.out", ios: : in | ios: : out | ios: :binary);
	
		fp.clear();
	
fp.seekp(offset, ios: :beg);
	
		
		int             i = 0;
	
		int             j;
	
		//Writing the node to the file 
		char           *n_value = new char[4];
	
		sprintf(n_value, "%d", node->n);
	
		//cout << "Key counts:" << node->n;
	
		fp.write(n_value, 4);
	
		
		char           *key_value = new char[4 * (ORDER - 1)];
	
		for (i = 0, j = 0; i < 4 * (ORDER - 1); i = i + 4, j++) {
		
			
			sprintf(key_value + i, "%d", node->key[j]);
		
	} 
		
		fp.write(key_value, 4 * (ORDER - 1));
	
		
		
		char           *child_value = new char[4 * ORDER];
	
		for (i = 0, j = 0; i < 4 * ORDER; i = i + 4, j++) {
		
			
			sprintf(child_value + i, "%ld", node->child[j]);
		
	} 
		
		fp.write(child_value, 4 * ORDER);
	
		
		//cout << "Node written successfully";
	
		fp.close();
	
		return (offset);
	
		
} 

long 
append_node(btree_node * node)
{
	
	
	ofstream fp;
	
		//cout << "in the append_node function";
	
fp.open("btree.out", ios: :app);
	
		fp.clear();
	
fp.seekp(0, ios: :end);
	
		long            offset = fp.tellp();
	
		
		int             i = 0;
	
		int             j;
	
		//Appending the node to the file 
		char           *n_value = new char[4];
	
		sprintf(n_value, "%d", node->n);
	
		//cout << "Key counts:" << node->n;
	
		fp.write(n_value, 4);
	
		
		char           *key_value = new char[4 * (ORDER - 1)];
	
		for (i = 0, j = 0; i < 4 * (ORDER - 1); i = i + 4, j++) {
		
			
			sprintf(key_value + i, "%d", node->key[j]);
		
	} 
		
		fp.write(key_value, 4 * (ORDER - 1));
	
		
		
		char           *child_value = new char[4 * ORDER];
	
		for (i = 0, j = 0; i < 4 * ORDER; i = i + 4, j++) {
		
			
			sprintf(child_value + i, "%ld", node->child[j]);
		
	} 
		
		fp.write(child_value, 4 * ORDER);
	
		
		//cout << "Node appended successfully";
	
		fp.close();
	
		
		return (offset);
	
		
		
} 

btree_node * read_node(long offset)
{
	
		
		btree_node * node = new btree_node;
	
		fstream fp;
	
		
fp.open("btree.out", ios: :in);
	
		fp.clear();
	
fp.seekp(offset, ios: :beg);
	
		
		//Reading the node from the file 
		
		char           *n_value = new char[4];
	
		fp.read(n_value, 4);
	
		node->n = atol(n_value);
	
		
		
		char           *key_value = new char[4];
	
		
		for (int i = 0; i < ORDER - 1; i++) {
		
			
			fp.read(key_value, 4);
		
			node->key[i] = atol(key_value);
		
			
	} 
		
		char           *child_value = new char[4];
	
		
		for (int i = 0; i < ORDER; i++) {
		
			
			fp.read(child_value, 4);
		
			node->child[i] = atol(child_value);
		
			
	} 
		
		//cout << "Node Read successfully" << endl;
	
		
	/*
	 * cout<<"Keycount:"<<node->n; for(int i=0;i<ORDER-1;i++)
	 * ->key[i]; for(int i=0;i<ORDER;i++) cout<<node->child[i];
		 */ 
		fp.close();
	
		return (node);
	
		
} 
/*
 * Function:get_median Once the node starts overflowing  get_median method
 * copies the node into a bigger array and inserts the new key in proper
 * tion. It then returns the median key index position.
 */ 

int 
get_median(btree_node * node, int key, btree_node_temp * temp1)
{
	
	
	cout << "In the get median";
	
		btree_node * buffer = new btree_node;
	
		buffer = node;
	
		if (check_leaf(node) == 1) {
		node->leaf = true;
	} else {
		node->leaf = false;
	} 
		btree_node_temp * temp = new btree_node_temp;
	
		temp = temp1;
	
		int             keycount = buffer->n;
	
		cout << "Keycount:" << keycount;
	
		
		while (keycount > 0 && key < buffer->key[keycount - 1]) {
		
			
			temp->key[keycount] = buffer->key[keycount - 1];
		
			
			if (!(node->leaf)) {
			
				temp->child[keycount + 1] = buffer->child[keycount];
			
		} 
			keycount--;
		
			
	} 
		temp->key[keycount] = key;
	
		
		if (!(node->leaf)) {
		
			temp->child[keycount + 1] = buffer->child[keycount];
		
			//temp->child[keycount + 1] = buffer->child[keycount];
		
	} 
		keycount--;
	
		
		
		while (keycount >= 0) {
		
			temp->key[keycount] = buffer->key[keycount];
		
			
			if (!(node->leaf)) {
			
				temp->child[keycount + 1] = buffer->child[keycount + 1];
			
		} 
			
			keycount--;
		
	} 
		
		if (!(node->leaf)) {
		
			temp->child[keycount] = buffer->child[keycount];
		
	} 
		
		temp->n = buffer->n + 1;
	//value is now 33 
		
		cout << "value of temp->n" << temp->n;
	
		cout << "temp->n array" << endl;
	
		for (int i = 0; i < temp->n; i++) {
		
			cout << temp->key[i] << "\t";
		
	} 
		cout << "temp->n + 1 child array" << endl;
	
		for (int i = 0; i < temp->n + 1; i++) {
		
			cout << temp->child[i] << "\t";
		
	} 
		
		
		cout << "Median:" << ((temp->n - 1) / 2);
	//Median index is 16 i.e(0 - 15 & 17 - 32) 
		return ((temp->n - 1) / 2);
	
		
		
} 

void 
split_parent(btree_node * grand_parent, int child_no, btree_node * parent, int key, long parent_offset, long grand_parent_offset, long end_child_offset)
{
	
	
	int             j;
	
		btree_node * new_root = new btree_node;
	
		btree_node_temp * temp = new btree_node_temp;
	
		//int           median_key = get_median(parent, key, temp);
	
		int             median_key = key;
	
		
		btree_node * sibling = allocate_node();
	
		if (check_leaf(parent) == true) {
		sibling->leaf = true;
	} else {
		sibling->leaf = false;
	} 
		sibling->n = (ORDER - 1) / 2;
	
		
		for (j = 0; j < sibling->n; j++) {
		
			sibling->key[j] = temp->key[j + ((ORDER - 1) / 2) + 1];
		
			
			if (!(sibling->leaf)) {
			
				sibling->child[j] = temp->child[j + ((ORDER - 1) / 2)];
			
		} 
			
	} 
		sibling->child[j] = end_child_offset;
	
		
		parent->n = (ORDER - 1) / 2;
	
		
		int             keycount = grand_parent->n;
	
		while (keycount > 0 && child_no < (keycount - 1)) {
		
			
			grand_parent->key[keycount] = grand_parent->key[keycount - 1];
		
			grand_parent->child[keycount + 1] = grand_parent->child[keycount];
		
			keycount--;
		
			
	} 
		
		grand_parent->key[keycount] = parent->key[median_key];
	
		grand_parent->child[child_no] = write_node(parent, parent_offset);
	
		grand_parent->child[child_no + 1] = append_node(sibling);
	
		
		grand_parent->n = grand_parent->n + 1;
	
		
		write_node(grand_parent, grand_parent_offset);
	
		parents.pop_back();
	
		
		delete temp;
	
		delete new_root;
	
		delete sibling;
	
} 



void 
split_child(btree_node * parent, int child_no, btree_node * child, int key, long offset)
{
	
	
	bool split_flag = false;
	
		int             median_key_parent;
	
		int             j;
	
		btree_node * new_root = new btree_node;
	
		btree_node * grand_parent = new btree_node;
	
		btree_node * parent_sibling = new btree_node;
	
		btree_node_temp * temp = new btree_node_temp;
	
		btree_node_temp * temp_parent = new btree_node_temp;
	
		btree_node * sibling;
	
		
		int             median_key = get_median(child, key, temp);
	
		
		if (parent->n == ORDER - 1 && child->n == ORDER - 1) {
		
			split_flag = true;
		
			//parents.pop_back();
		
	} 
		
		sibling = allocate_node();
	
		if (check_leaf(child) == true) {
		sibling->leaf = true;
	} else {
		sibling->leaf = false;
	} 
		sibling->n = ((ORDER - 1) / 2);
	
		
		for (j = 0; j < sibling->n; j++) {
		
			sibling->key[j] = temp->key[j + ((ORDER - 1) / 2) + 1];
		
			
			if (!(sibling->leaf)) {
			
				sibling->child[j] = temp->child[j + ((ORDER - 1) / 2) + 1];
			
		} 
			
	} 
		if (sibling->leaf == false) {
		sibling->child[j] = temp->child[j + ((ORDER - 1) / 2) + 1];
		
			
			
			
			child->n = (ORDER - 1) / 2;
		
			for (j = 0; j < child->n; j++) {
			
				child->key[j] = temp->key[j];
			
				
				if (!(child->leaf)) {
				
					child->child[j] = temp->child[j];
				
			} 
		} 
			if (child->leaf = false) {
			child->child[j] = temp->child[j];
		} 
			
			
			
			//The median key is promoted to the parent node and the child pointers are adjusted appropriately for the
			two split child nodes 
				if (split_flag == true) {
				
					
					int             median_key_parent = get_median(parent, temp->key[median_key], temp_parent);
				
					cout << "median_key_parent:" << temp_parent->key[median_key_parent];
				
					child_no = (long) childnos.back();
				
					cout << "Child_no:" << child_no;
				
					parent_sibling = allocate_node();
				
					temp_parent->child[child_no] = write_node(child, offset);
				
					temp_parent->child[child_no + 1] = append_node(sibling);
				
					
					
					
					if (check_leaf(parent) == true) {
					sibling->leaf = true;
				} else {
					sibling->leaf = false;
				} 
					parent_sibling->n = ((ORDER - 1) / 2);
				
					
					
					
					for (j = 0; j < parent_sibling->n; j++) {
					
						parent_sibling->key[j] = temp_parent->key[j + ((ORDER - 1) / 2) + 1];
					
						
						
						parent_sibling->child[j] = temp_parent->child[j + ((ORDER - 1) / 2) + 1];
					
						
						
				} 
					parent_sibling->child[j] = temp_parent->child[j + ((ORDER - 1) / 2) + 1];
				
					
					
					
					parent->n = (ORDER - 1) / 2;
				
					for (j = 0; j < parent->n; j++) {
					
						parent->key[j] = temp_parent->key[j];
					
						parent->child[j] = temp_parent->child[j];
					
						
				} 
					parent->child[j] = temp_parent->child[j];
				
					
					
					
					
					
					
					
					
					
					long            grand_parent_offset;
				
					for (int i = 0; i < parents.size(); i++) {
					
						cout << "parents offset:" << parents.at(i);
					
				} 
					for (int i = 0; i < childnos.size(); i++) {
					
						cout << "child no:" << childnos.at(i);
					
				} 
					
					
					
					
					
					int             size = (int) childnos.size();
				
					
					if (size == 1) {
					
						parents.pop_back();
					
						long            parent_offset = (long) parents.back();
					
						grand_parent = allocate_root();
					
						grand_parent->key[0] = temp_parent->key[median_key_parent];
					
						grand_parent->child[0] = write_node(parent, parent_offset);
					
						grand_parent->child[1] = append_node(parent_sibling);
					
						grand_parent->n = 1;
					
						grand_parent_offset = append_node(grand_parent);
					
						root_offset = grand_parent_offset;
					
						cout << "root offset:" << root_offset;
					
						
						
						
				} 
					
					else {
					
						parents.pop_back();
					
						//parents.pop_back();
					
						childnos.pop_back();
					
						cout << "parent_offset:" << (long) parents.back();
					
						
						child_no = (int) childnos.back();
					
						grand_parent_offset = root_offset;
					
						grand_parent = read_node(grand_parent_offset);
					
						long            parent_offset = (long) parents.back();
					
						grand_parent->key[child_no] = temp_parent->key[median_key_parent];
					
						grand_parent->child[child_no] = write_node(parent, parent_offset);
					
						parents.pop_back();
					
						grand_parent->child[child_no + 1] = append_node(parent_sibling);
					
						parents.push_back(grand_parent->child[child_no + 1]);
					
						parent_offset = (long) parents.back();
					
						
						
						grand_parent->n = grand_parent->n + 1;
					
						childnos.clear();
					
						write_node(grand_parent, grand_parent_offset);
					
						
						
				} 
					
			} 
				else {
				
					
					
					int             keycount = parent->n;
				
					while (keycount > 0 && child_no < keycount) {
					
						
						parent->key[keycount] = parent->key[keycount - 1];
					
						parent->child[keycount + 1] = parent->child[keycount];
					
						keycount--;
					
						
				} 
					
					cout << "child_no" << child_no;
				
					parent->key[child_no] = temp->key[median_key];
				
					parent->child[child_no] = write_node(child, offset);
				
					parent->child[child_no + 1] = append_node(sibling);
				
					
					parent->n = parent->n + 1;
				
					
					if (root_offset == 0) {
					
						
						root_offset = append_node(parent);
					
						
				} 
					else {
					
						
						parents.pop_back();
					
						write_node(parent, (long) parents.back());
					
						
						
				} 
					
			} 
			
			delete temp;
		
			delete temp_parent;
		
	} 
	/*
	 * Function:insert_nonfull Arguments: node and key to be inserted
	 * sc: This method inserts the key in the node based on whether it is
	 * a leaf or non-leaf node
		 */ 
		void            insert_nonfull(btree_node * node, int key, long offset) {
		
		
		btree_node * buffer = new btree_node;
		
		buffer = node;
		
		btree_node * child = new btree_node;
		
		
		
		
		int             keycount = buffer->n;
		               
		              //cout << "buffer->n" << buffer->n;
		               
		if              (offset != 0) {
			
			if (check_leaf(node)) {
				buffer->leaf = true;
			} else {
				buffer->leaf = false;
			} 
				
		} 
			
			
			
			//If the node is a leaf and if it
			is not full then insert the key in its proper position in the node 
				if (buffer->leaf == true) {
				
					//cout << "Leaf:" << buffer->leaf;
				
					
					
					
					while (keycount > 0 && key < buffer->key[keycount - 1]) {
					
						
						buffer->key[keycount] = buffer->key[keycount - 1];
					
						keycount--;
					
				} 
					
					
					buffer->key[keycount] = key;
				
					buffer->n = buffer->n + 1;
				
					write_node(buffer, offset);
				
					
					
				/*
				 * cout<<"Parents:"<<(int)parents.size();
				 * t<<"Parent offsets:"<<endl;
				 * .begin();it < parents.end(); it++){
				 * "  " <<*it; }
					 */ 
					//cout << "in the leaf";
				
					parents.clear();
				
					
					
			} 
			
		/*
		 * If the node is not a leaf then look for the appropriate
		 * child pointer based on the key and read the child node.And
		 * if the  child node is a leaf then insert the key in its
		 * proper position. Else look for the appropriate child
		 * pointer in the child  node and do it recursively until
		 * you find a leaf.
			 */ 
			
				else {
				
					parents.push_back(offset);
				
					
					for (unsigned i = 0; i < parents.size(); i++) {
					
						
						cout << "parents array :" << parents[i];
					
						
				} 
					
					while (keycount > 0 && key < buffer->key[keycount - 1]) {
					
						
						keycount--;
					
				} 
					
					childnos.push_back(keycount);
				
					
					
					//cout << "keycount off set:" << buffer->child[keycount];
				
					child = read_node(buffer->child[keycount]);
				
					
					
					
					if (check_leaf(child)) {
					child->leaf = true;
				} else {
					child->leaf = false;
				} 
					
					if (child->n == ORDER - 1 && child->leaf == true) {
					
						parents.push_back(buffer->child[keycount]);
					
						
						split_child(buffer, keycount, child, key, buffer->child[keycount]);
					
				} 
					else {
					
						insert_nonfull(child, key, buffer->child[keycount]);
					
				} 
			} 
			
	} 
		
		void            add_key(int key) {
		
		btree_node * node = new btree_node;
		
		parents.clear();
		
		childnos.clear();
		
		node = read_node(root_offset);
		
		btree_node * new_root;
		
		//parents.push_back(root_offset);
		
		
		
		
		/*
		 * if(root_offset != 0 && check_leaf(node) == 1){ node->leaf
		 * = true; } else{ node->leaf=false; }
		 */ 
		
		if (root_offset == 0) {
			
			node->leaf = true;
			
		}              
		else
			               
			                node->leaf = false;
		
			
			
			if (node->n == ORDER - 1 && root_offset == 0) {
			
				//cout << "in plit";
			
				new_root = allocate_root();
			
				split_child(new_root, 0, node, key, root_offset);
			
				
		} 
			
			else {
			
				//cout << "root_offset:" << root_offset;
			
				insert_nonfull(node, key, root_offset);
			
				
				
		} 
			
			
			
	} 
		
		bool find(btree_node * node, int value) {
		
			
			btree_node * buffer = new btree_node;
		
			buffer = node;
		
			
			
			btree_node * child = new btree_node;
		
			int             keycount = node->n;
		
			int             flag = 0;
		
			
			if (node->leaf == true) {
			
				
				
				while (keycount >= 0 && value <= buffer->key[keycount - 1]) {
				
					
					if (value > buffer->key[keycount - 1]) {
					
						flag = 0;
					
						break;
					
						
				} 
					
					if (value == buffer->key[keycount - 1]) {
					
						flag = 1;
					
						break;
					
						
				} 
					else {
					
						keycount--;
					
				} 
			} 
				
				
				
				
				
		} 
			
			else {
			
				//cout << "Inside the if";
			
				while (keycount > 0 && value <= buffer->key[keycount - 1]) {
				
					if (value == buffer->key[keycount - 1]) {
					
						//cout << "Value matched";
					
						//cout << value << "found";
					
						flag = 1;
					
						return (flag);
					
						
						
				} 
					else {
					
						keycount--;
					
				} 
					
					
			} 
				child = read_node(buffer->child[keycount]);
			
				if (check_leaf(child)) {
				child->leaf = true;
			} else {
				child->leaf = false;
			} 
				flag = find(child, value);
			
				
				
		} 
			
			if (flag == 1) {
			
				flag = 0;
			
				return true;
			
		} 
			else {
			
				return false;
			
		} 
			
			
			
	} 
		
		bool find_key(int value) {
		
			
			time_t start, end;
		
			double          diff;
		
			time(&start);
		
			btree_node * node = new btree_node;
		
			node = read_node(root_offset);
		
			bool result;
		
			
			//cout << "root offset:" << root_offset;
		
			if (root_offset == 0) {
			
				node->leaf = true;
			
		} 
			else {
			
				node->leaf = false;
			
		} 
			result = find(node, value);
		
			time(&end);
		
			diff = difftime(end, start);
		
			sum = sum + diff;
		
			return (result);
		
			
	} 
		
		void            print() {
		
		
		int             print_level = 0;
		               
		int             child_count;
		               
		                queue < level_node > nodequeue;
		               
		                level_node cur_level;
		               
		                level_node qhead;
		               
		                btree_node * node = new btree_node;
		               
		               
		                node = read_node(root_offset);
		               
		if              (check_leaf(node) == true) {
			node->leaf = true;
		} else {
			node->leaf = false;
		} 
			
			cur_level.node = node;
		
			cur_level.level = 1;
		
			cur_level.offset = root_offset;
		
			cout << "root_offset:" << root_offset;
		
			
			nodequeue.push(cur_level);
		
			
			while (!nodequeue.empty()) {
			
				qhead = nodequeue.front();
			
				child_count = qhead.node->n;
			
				
				if (qhead.node->leaf == false) {
				
					for (int i = 0; i <= child_count; i++) {
					
						node = read_node(qhead.node->child[i]);
					
						if (check_leaf(node) == true) {
						node->leaf = true;
					} else {
						node->leaf = false;
					} 
						cur_level.node = node;
					
						cur_level.level = qhead.level + 1;
					
						cur_level.offset = qhead.node->child[i];
					
						
						nodequeue.push(cur_level);
					
						
				} 
			} 
				
				if (print_level < qhead.level) {
				
					
					print_level++;
				
					cout << "\n";
				
					cout << print_level << ": ";
				
					
			} 
				
				for (int i = 0; i < child_count; i++) {
				
					
					cout << qhead.node->key[i];
				
					
					if (i != child_count - 1) {
					
						cout << ",";
					
				} 
			} 
				cout << "/" << qhead.offset << " ";
			
				
				nodequeue.pop();
			
				
				
				
		} 
			delete node;
		
			getch();
		
	} 
		
		
		int             main(int argc, char *argv[]) {
		
		
		//cout << "Removing the existing index file";
		
		system("rm btree.out");
		
		//cout << "removed";
		
		
		int             count = 0;
		               
		                fstream fp;
		              //file pinter for the input file 
		                fstream index_fp; //file pointer for the index file 
		                const char *inputfile = argv[2];
		               
		                string line;
		               
		                size_t position;
		               
		                string command;
		               
		                string temp;
		               
		int             value;
		               
		               
		               
		               
                fp.open("btree.out", ios: :                out);
		               
		                fp.close();
		               
		               
		              //cout << "Input file is:" << inputfile;
		               
		               
                fp.open(inputfile, ios: :                 in | ios: :                out);
		              //Opening the input file 
		               
		if              (fp.is_open()) {
			
			
			fp.clear();
			
	fp.seekg(0, ios: :beg);
			
			
			create_empty_btree();
			//Creating an empty root node 
			while (!fp.eof()) {
				
				
				getline(fp, line);
				
				position = line.find(" ");
				
				command = line.substr(0, position);
				
				//cout << command;
				
				
				if (command == "add" | command == "find" | command == "print")
					
				{
					
					temp = line.substr(position + 1);
					
					value = atoi(temp.c_str());
					//Converting a constant char *into int 
					              //cout << ' ' << value;
					               
					               
					if              (command == "add") {
						
						//cout << "Value to be added:" << value;
						
						add_key(value);
						
					}              
					               
					if              (command == "find") {
						
						count++;
						
							bool find_result = find_key(value);
						
							if (find_result) {
							
								cout << "\nRecord " << value << " exists";
							
						} 
							else {
							
								cout << "\nRecord " << value << " does not exist";
							
						} 
							
					} 
						
						if (command == "print") {
						
							
							cout << "Number of nodes in the tree:" << count << endl;
						
							print();
						
							cout << "\n";
						
							printf("\nSum:%.6lf", sum);
						
							printf("\nAvg:%.6lf", sum / (double) count);
						
							
					} 
						
						if (command == "exit") {
						
							exit(1);
						
					} 
				} 
					
					//cout << "\n";
				
					//timer();
				
			} 
				fp.close();
			
		} 
			
			else
			
				cout << "Input file is closed";
		
			
			getch();
		
			return 0;
		
			
	} 
		
		
