#+SETUPFILE: ~/emacs/org-templates/level-0.org
#+TITLE: Real World Haskell -  Bryan O'Sullivan, Don Stewart, and John Goerzen

* Real World Haskell

This is a book that I attempted to go through once but then gave up
because of lack of time. But I guess I will finish going through it
this time. Also this book is available free online
[[http://book.realworldhaskell.org/][here]].


* Types and functions

** Why care about types

   - *Every* expression in haskell has a type.
      - The type of a value indicates the properties it shares with
        other values of the same type.
   - At the lowest level information is represented in the form of
     plain bits types helps up build abstractions over that

** Haskell's type system
   - Its /strong, static and inferred/

*** Strong type
    - Indicates the programs written in this language will not contain
      the types of errors that occur by incorrectly passing around
      object of the wrong type.
    - It does not allow automatic coercion of types from one form to
      another. 
      - As result it can help up catch subtle bugs.

*** Static type
    - This means that the compiler knows the types of the values of
      the expressions during compile time.
      - This is cool because the compiler can perform analysis and
        figure out where we might have problems in the code.
*** Type infereence
    - The Haskell compiler can automagically deduce the type of
      expressions for us.
** What to expect from the type system

*** Some basic common types
    - =Char= - represents unicode characters
    - =Bool= - Boolean
    - =Int= - Integer where size is based on integer macchine size
    - =Integer= - Arbitrary sized integer, not as efficient as =Ints=
    - =Double= - It is suggested to use this instead of =Float= as
      peole are working to make this more efficent
*** Function application
    - It has higher precedence than anyother operator
    - Its left associative
*** Lists
    - Is a list of values where all the values have the same type
    - Concatenation operator: =++=
    - Cons operator: =:=
*** Tuples
    - Is a fixed size collection that can contains objects of many
      different types.
    - A tuple with zero elements =()= is called a /unit/ its similar
      to void in C
*** Exercise Solutions
    - Bool
    - (\[[Char]\], Char)
    - [(Bool, \[[Char]\]]
** Functions over Lists and tuples
*** List Functions
    - =take= takes two arguments an integer and a list and returns the
      first n element from the list
    - =drop= - takes two arguments an integer and a list and returns
      all but the first n elements from the list
*** Tuple Functions
    - =fst=, =snd= as the name suggest returns the first and second
      values from a two element tuple.
*** Function Types and purity
    - Typically in haskell the type signatures of functions is written
      as follows for example the type of the function say =lines= is
      =String->[String]= which essentially means that the function
      takes in one string argument and returns a list of strings.
    - =QUESTION= In the last line of the section the author mentions that
      Haskell's type system prevents us from mixing up pure and impure
      code. I thought it was because of haskell functional nature.

** Haskell source files and writing simple functions
*** Just what is a variable anyway
    - A variable in haskell is a means of naming expressions rather
      than a name give to a storage location in the memory
    - /Note about indentation/ Expressions with the same level of
      indentation continue the expression.
** Polymorphism in haskell
   - When a function has /type variables/ in its signature we call it
     polymorphic. Type variable can be identified because usually they
     are in lower case.
   - The type of polymorphism provided by haskell is called
     /parametric polymorphism/. If a type contains type parameters we
     say that it is a parameterized type or a polymorphic type. A
     parametric type in Haskell is very similar to a generic type in java.
** Functions with more that one argument
   - For example if we take a funciton like =drop= we see that its
     type signature is =Int->[a]->[a]=. Since =->= is right
     associative we can write the signature as =Int->([a]->[a])=, what
     it essentially means is that every function in haskell takes in
     one argument and returns a value, but in this case what we see is
     that it takes an =Int= argument and returns a function of that
     takes a list and returns a list.

* Data types and stream lining functions
** Defining new data types
Defining new data types make coding quite safe for us cause we would
not pass in incorrect data to functions. This is essentially achieved
because by defining data types we force the haskell compiler to verify
our the data types in our code.

 New data types are defined using the the data
 keyword. This expressions defines the *type constructor* and the
 *value constructor*.  We refer to the data types generated by    
 using the name given by its type constructor and as the name suggests
 we use a value  constructor to build values. But in most code it so
 happens that /both/ the value and type constructors have the same name

/Question/
  * Firstly, why is the use of the value constructors so very
    inconsistent, because when we use plain integers, or floats we don't
    use it but we do use it for user defined types. So is that a reason
    its there because its for user defined types.

 So after reading further down I figured that, value constructors are
 treated like functions. More details can be obtained using the 
 =:info=

*** Type synonyms

Type synonyms are synonyms for existing data types. They serve the
purpose of making the existing code readable. They are created using
the =type= keyword

*** Algebraic Data types

Is a data type that has <b>more than one </b> value constructor. They
are separated using the "|" character.

The point of using user defined data types over standard constructs
like tuples is when we have to clarify the types we are dealing with.

Types can be used to perform the roles of equivalent features provided
by other languages like structures, enumerations, unions.

** Pattern Matching

Haskell provides a facility by which we can define functions are
series of equations what essentially is happening here is that at
Haskell performs run time checks and applies the appropriate
definition.

*** Construction and deconstruction
    - We construct values of a give type by invoking its value constructor
    - We /deconstruct/ a type by matching the value against a pattern
      the pattern of the type.
    - We use the =_= to represent a wildcard, to indicate that we
      don't care about a particular value
    - Something quite painful about the whole thing is that you have
      to go on writing a bunch of accessors that can be quite a
      pain. To get around that we have something called the record
      syntax where can specify the names of the accessors of the field
      immediately. 

#+BEGIN_SRC haskell
data BookInfo = Book {
      bookId :: Int
    , bookName :: String
    , authors :: [String]
    } deriving (Show)
#+END_SRC

    - The part before the =::= is the name of the accessor and the
      part after it is the type.
** Parameterized Types
   - We can create parameterized types by adding a type variable into
     our type declarations

#+BEGIN_SRC haskell
data Maybe a = Just a
             | Nothing
#+END_SRC
   - Heck this is quite cool!
** Exercise Solutions 
   - Ex 1
#+BEGIN_SRC
fromList Nil = []
fromList (Cons x xs) = x : fromList xs
#+END_SRC
   - Ex 2
#+BEGIN_SRC
data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a))  deriving
(Show)
#+END_SRC
** Errors
   - We can use the =error= function in haskell to throw up an error
** Local variables
   - Local variables can be defined using the =let...in...= statement
   - =let...in...= blocks can be nested, and if we have a variable in
     an inner let block that has the same name as another then the
     variable in the inner block /shadows/ the varianble in the outer block
