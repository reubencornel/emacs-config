<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Real World Haskell -  Bryan O'Sullivan, Don Stewart, and John Goerzen</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2009/12/25 17:43:58"/>
<meta name="author" content="Reuben Francis Cornel"/>
<link rel="stylesheet" type="text/css" href="orgstyle.css" />
</head><body>
<h1 class="title">Real World Haskell -  Bryan O'Sullivan, Don Stewart, and John Goerzen</h1>
<h2>Table of Contents</h2>
<ul>
<li><a href="#sec-1">1 Real World Haskell</a></li>
<li><a href="#sec-2">2 Types and functions</a>
<ul>
<li><a href="#sec-3">2.1 Why care about types</a></li>
<li><a href="#sec-4">2.2 Haskell's type system</a>
<ul>
<li><a href="#sec-5">2.2.1 Strong type</a></li>
<li><a href="#sec-6">2.2.2 Static type</a></li>
<li><a href="#sec-7">2.2.3 Type infereence</a></li>
</ul>
</li>
<li><a href="#sec-8">2.3 What to expect from the type system</a>
<ul>
<li><a href="#sec-9">2.3.1 Some basic common types</a></li>
<li><a href="#sec-10">2.3.2 Function application</a></li>
<li><a href="#sec-11">2.3.3 Lists</a></li>
<li><a href="#sec-12">2.3.4 Tuples</a></li>
<li><a href="#sec-13">2.3.5 Exercise Solutions</a></li>
</ul>
</li>
<li><a href="#sec-14">2.4 Functions over Lists and tuples</a>
<ul>
<li><a href="#sec-15">2.4.1 List Functions</a></li>
<li><a href="#sec-16">2.4.2 Tuple Functions</a></li>
<li><a href="#sec-17">2.4.3 Function Types and purity</a></li>
</ul>
</li>
<li><a href="#sec-18">2.5 Haskell source files and writing simple functions</a>
<ul>
<li><a href="#sec-19">2.5.1 Just what is a variable anyway</a></li>
</ul>
</li>
<li><a href="#sec-20">2.6 Polymorphism in haskell</a></li>
<li><a href="#sec-21">2.7 Functions with more that one argument</a></li>
</ul>
</li>
<li><a href="#sec-22">3 Data types and stream lining functions</a>
<ul>
<li><a href="#sec-23">3.1 Defining new data types</a>
<ul>
<li><a href="#sec-24">3.1.1 Type synonyms</a></li>
<li><a href="#sec-25">3.1.2 Algebraic Data types</a></li>
</ul>
</li>
<li><a href="#sec-26">3.2 Pattern Matching</a>
<ul>
<li><a href="#sec-27">3.2.1 Construction and deconstruction</a></li>
</ul>
</li>
<li><a href="#sec-28">3.3 Parameterized Types</a></li>
<li><a href="#sec-29">3.4 Exercise Solutions </a></li>
<li><a href="#sec-30">3.5 Errors</a></li>
<li><a href="#sec-31">3.6 Local variables</a></li>
<li><a href="#sec-32">3.7 The case expression</a></li>
<li><a href="#sec-33">3.8 Guards</a></li>
</ul>
</li>
</ul>

<h2><a name="sec-1">1 Real World Haskell</a></h2>


<p>
This is a book that I attempted to go through once but then gave up
because of lack of time. But I guess I will finish going through it
this time. Also this book is available free online
<a href="http://book.realworldhaskell.org/">here</a>.
</p>


<h2><a name="sec-2">2 Types and functions</a></h2>



<h3><a name="sec-3">2.1 Why care about types</a></h3>


<ul>
<li>
<b>Every</b> expression in haskell has a type.
<ul>
<li>
The type of a value indicates the properties it shares with
other values of the same type.
</li>
</ul></li>
<li>
At the lowest level information is represented in the form of
plain bits types helps up build abstractions over that

</li>
</ul>
<h3><a name="sec-4">2.2 Haskell's type system</a></h3>

<ul>
<li>
Its <i>strong, static and inferred</i>

</li>
</ul>
<h4><a name="sec-5">2.2.1 Strong type</a></h4>

<ul>
<li>
Indicates the programs written in this language will not contain
the types of errors that occur by incorrectly passing around
object of the wrong type.
</li>
<li>
It does not allow automatic coercion of types from one form to
another. 
<ul>
<li>
As result it can help up catch subtle bugs.

</li>
</ul></li>
</ul>
<h4><a name="sec-6">2.2.2 Static type</a></h4>

<ul>
<li>
This means that the compiler knows the types of the values of
the expressions during compile time.
<ul>
<li>
This is cool because the compiler can perform analysis and
figure out where we might have problems in the code.
</li>
</ul></li>
</ul>
<h4><a name="sec-7">2.2.3 Type infereence</a></h4>

<ul>
<li>
The Haskell compiler can automagically deduce the type of
expressions for us.
</li>
</ul>
<h3><a name="sec-8">2.3 What to expect from the type system</a></h3>



<h4><a name="sec-9">2.3.1 Some basic common types</a></h4>

<ul>
<li>
<code>Char</code> - represents unicode characters
</li>
<li>
<code>Bool</code> - Boolean
</li>
<li>
<code>Int</code> - Integer where size is based on integer macchine size
</li>
<li>
<code>Integer</code> - Arbitrary sized integer, not as efficient as <code>Ints</code>
</li>
<li>
<code>Double</code> - It is suggested to use this instead of <code>Float</code> as
peole are working to make this more efficent
</li>
</ul>
<h4><a name="sec-10">2.3.2 Function application</a></h4>

<ul>
<li>
It has higher precedence than anyother operator
</li>
<li>
Its left associative
</li>
</ul>
<h4><a name="sec-11">2.3.3 Lists</a></h4>

<ul>
<li>
Is a list of values where all the values have the same type
</li>
<li>
Concatenation operator: =++=
</li>
<li>
Cons operator: =:=
</li>
</ul>
<h4><a name="sec-12">2.3.4 Tuples</a></h4>

<ul>
<li>
Is a fixed size collection that can contains objects of many
different types.
</li>
<li>
A tuple with zero elements <code>()</code> is called a <i>unit</i> its similar
to void in C
</li>
</ul>
<h4><a name="sec-13">2.3.5 Exercise Solutions</a></h4>

<ul>
<li>
Bool
</li>
<li>
(\[[Char]\], Char)
</li>
<li>
[(Bool, \[[Char]\]]
</li>
</ul>
<h3><a name="sec-14">2.4 Functions over Lists and tuples</a></h3>


<h4><a name="sec-15">2.4.1 List Functions</a></h4>

<ul>
<li>
<code>take</code> takes two arguments an integer and a list and returns the
first n element from the list
</li>
<li>
<code>drop</code> - takes two arguments an integer and a list and returns
all but the first n elements from the list
</li>
</ul>
<h4><a name="sec-16">2.4.2 Tuple Functions</a></h4>

<ul>
<li>
<code>fst</code>, <code>snd</code> as the name suggest returns the first and second
values from a two element tuple.
</li>
</ul>
<h4><a name="sec-17">2.4.3 Function Types and purity</a></h4>

<ul>
<li>
Typically in haskell the type signatures of functions is written
as follows for example the type of the function say <code>lines</code> is
<code>String-&gt;[String]</code> which essentially means that the function
takes in one string argument and returns a list of strings.
</li>
<li>
<code>QUESTION</code> In the last line of the section the author mentions that
Haskell's type system prevents us from mixing up pure and impure
code. I thought it was because of haskell functional nature.

</li>
</ul>
<h3><a name="sec-18">2.5 Haskell source files and writing simple functions</a></h3>


<h4><a name="sec-19">2.5.1 Just what is a variable anyway</a></h4>

<ul>
<li>
A variable in haskell is a means of naming expressions rather
than a name give to a storage location in the memory
</li>
<li>
<i>Note about indentation</i> Expressions with the same level of
indentation continue the expression.
</li>
</ul>
<h3><a name="sec-20">2.6 Polymorphism in haskell</a></h3>

<ul>
<li>
When a function has <i>type variables</i> in its signature we call it
polymorphic. Type variable can be identified because usually they
are in lower case.
</li>
<li>
The type of polymorphism provided by haskell is called
<i>parametric polymorphism</i>. If a type contains type parameters we
say that it is a parameterized type or a polymorphic type. A
parametric type in Haskell is very similar to a generic type in java.
</li>
</ul>
<h3><a name="sec-21">2.7 Functions with more that one argument</a></h3>

<ul>
<li>
For example if we take a funciton like <code>drop</code> we see that its
type signature is <code>Int-&gt;[a]-&gt;[a]</code>. Since <code>-&gt;</code> is right
associative we can write the signature as <code>Int-&gt;([a]-&gt;[a])</code>, what
it essentially means is that every function in haskell takes in
one argument and returns a value, but in this case what we see is
that it takes an <code>Int</code> argument and returns a function of that
takes a list and returns a list.

</li>
</ul>
<h2><a name="sec-22">3 Data types and stream lining functions</a></h2>


<h3><a name="sec-23">3.1 Defining new data types</a></h3>

<p>Defining new data types make coding quite safe for us cause we would
not pass in incorrect data to functions. This is essentially achieved
because by defining data types we force the haskell compiler to verify
our the data types in our code.
</p>
<p>
New data types are defined using the the data
keyword. This expressions defines the <b>type constructor</b> and the
<b>value constructor</b>.  We refer to the data types generated by    
using the name given by its type constructor and as the name suggests
we use a value  constructor to build values. But in most code it so
happens that <i>both</i> the value and type constructors have the same name
</p>
<p>
<i>Question</i>
</p><ul>
<li>
Firstly, why is the use of the value constructors so very
inconsistent, because when we use plain integers, or floats we don't
use it but we do use it for user defined types. So is that a reason
its there because its for user defined types.

</li>
</ul>So after reading further down I figured that, value constructors are
treated like functions. More details can be obtained using the 
<code>:info</code>


<h4><a name="sec-24">3.1.1 Type synonyms</a></h4>


<p>
Type synonyms are synonyms for existing data types. They serve the
purpose of making the existing code readable. They are created using
the <code>type</code> keyword
</p>

<h4><a name="sec-25">3.1.2 Algebraic Data types</a></h4>


<p>
Is a data type that has &lt;b&gt;more than one &lt;/b&gt; value constructor. They
are separated using the "|" character.
</p>
<p>
The point of using user defined data types over standard constructs
like tuples is when we have to clarify the types we are dealing with.
</p>
<p>
Types can be used to perform the roles of equivalent features provided
by other languages like structures, enumerations, unions.
</p>

<h3><a name="sec-26">3.2 Pattern Matching</a></h3>


<p>
Haskell provides a facility by which we can define functions are
series of equations what essentially is happening here is that at
Haskell performs run time checks and applies the appropriate
definition.
</p>

<h4><a name="sec-27">3.2.1 Construction and deconstruction</a></h4>

<ul>
<li>
We construct values of a give type by invoking its value constructor
</li>
<li>
We <i>deconstruct</i> a type by matching the value against a pattern
the pattern of the type.
</li>
<li>
We use the =_= to represent a wildcard, to indicate that we
don't care about a particular value
</li>
<li>
Something quite painful about the whole thing is that you have
to go on writing a bunch of accessors that can be quite a
pain. To get around that we have something called the record
syntax where can specify the names of the accessors of the field
immediately. 

</li>
</ul>data BookInfo = Book {
bookId :: Int
, bookName :: String
, authors :: [String]
} deriving (Show)

<ul>
<li>
The part before the <code>::</code> is the name of the accessor and the
part after it is the type.
</li>
</ul>
<h3><a name="sec-28">3.3 Parameterized Types</a></h3>

<ul>
<li>
We can create parameterized types by adding a type variable into
our type declarations

</li>
</ul>data Maybe a = Just a
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<COL align="left">
<tbody>
<tr><td>Nothing</td></tr>
</tbody>
</table>

<ul>
<li>
Heck this is quite cool!
</li>
</ul>
<h3><a name="sec-29">3.4 Exercise Solutions </a></h3>

<ul>
<li>
Ex 1
</li>
</ul>fromList Nil = []
fromList (Cons x xs) = x : fromList xs
<ul>
<li>
Ex 2
</li>
</ul>data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a))  deriving
(Show)

<h3><a name="sec-30">3.5 Errors</a></h3>

<ul>
<li>
We can use the <code>error</code> function in haskell to throw up an error
</li>
</ul>
<h3><a name="sec-31">3.6 Local variables</a></h3>

<ul>
<li>
Local variables can be defined using the <code>let...in...</code> statement
</li>
<li>
<code>let...in...</code> blocks can be nested, and if we have a variable in
an inner let block that has the same name as another then the
variable in the inner block <i>shadows</i> the varianble in the outer block
</li>
</ul>
<h3><a name="sec-32">3.7 The case expression</a></h3>

<p>=case variable of
pattern  -&gt; value
pattern -&gt; value
=
</p>
<h3><a name="sec-33">3.8 Guards</a></h3>

<ul>
<li>
Used for conditional evaluation
</li>
<li>
All expressions must be <code>Bool</code>
</li>
<li>
The variable <code>otherwise</code> is bound to <code>True</code>

</li>
</ul>
<p class="author"> Author: Reuben Francis Cornel
<a href="mailto:reuben@odin.local">&lt;reuben@odin.local&gt;</a>
</p>
<p class="date"> Date: 2009/12/25 17:43:58</p>
</body>
</html>
