* Requirements
** QUESTION What is virtual window in act-r? 
When we cannot generate a real window...the system uses a common lisp representation of the windows. Thats called a virtual window
** Write a twenty question program 
Done found a program that throws out question
** that would ask questions to the twenty questions game
* Wordnet							    :WORDNET:
   - Word net is a large lexical database of english.
   - Words are grouped based on their cognitive synonyms
   - These are interlinked by conceptual sematic relations
** Meronym   :MERONYM:HOLONYM:
A meronym denotes a constituent part of, or a member of
something.

    X is a meronym of Y if Xs are parts of Y(s), or
    X is a meronym of Y if Xs are members of Y(s).

For example, 'finger' is a meronym of 'hand' because a finger is part
of a hand. Similarly 'wheel' is a meronym of 'automobile'. 

A Holonym is the opposite of Meronym
** Hyponyms  :HYPONYMS:HYPERNYMS:
In linguistics, a hyponym is a word or phrase whose semantic range is
included within that of another word, its hypernym. For example,
scarlet, vermilion, carmine, and crimson are all hyponyms of red
(their hypernym), which is, in turn, a hyponym of colour  
* ACT-R Tutorials 						   :TUTORIAL:
** Unit 1
*** Chunks
**** Elements of declarative knowledge are called chunks
***** These are element of knowledge a person may be expected to have when solving a problem
**** Chunks are defined By
***** Type
Eg: Birds
***** Slots
Eg: CanFly, Colour
If slots are not mentioned they are set to nil
**** The "type" slot defines the type of the slot
*** Productions
**** is a statement that controls behaviour
**** The condition in a prodution is the various state of a buffer.
**** the "Then" part consists of instructions of the stuff that has to filled in the buffers.
**** Writing Productions
***** The If Section
The first thing to be check is that is the chuck in the buffer the same type as what I want. The the slots are tested	
The prefix "=" before a name indicates that the current name is a variable. The scope of the variable is restricted to the particular production only

***** The action section of the production
****** When an action is prefixed with =
Causes the buffer to be modified

****** When an action is prefixed with +
The action is to communicate with the module of the buffer.
  - With the retrival buffer the action is to get the specified chunk from the declarative memory based on specs
****** WHen the buffer is prefixed with -
The action is the clear the buffer. Buffers are clear implicitly when a retrival is done.

****** !output! is used to display stuff
The typical way to use it would be to !output! (=num) num is the variable that is used to display stuff.
*** Creating Knowledge Elements
**** Chunks are defined by the "chunk-type" command
(chunk-type name slot-name-1 slot-name-2)
**** The "add-dm" command adds the chunks to declarative memory
**** Buffers
***** are means by which the procedural memory system and other components in ACT-R architecture interface
***** Each buffer can hold only one chunk at a time
** Unit 2 - Motor Module
*** Perception and motor actions
  Earlier they had a called perception and motor actions but then they
  integrated it into the main act-r system. to start an experiment type
  (do-experiment)

  The *actr-enabled-p* global variable indicates if a given model is active.
*** Imaginal module
*** Visual module
This module consists of two buffers
    - visual: Holds the representation of the object
    - visual-location: Holds the representation for the location of the object
** Writing Modules                                               :MODULES:
*** Defining modules
Modules are defined by the "define-module" command which has to be run
when no models are loaded. When a module is defined it has to provide
a couple of bits of information
- Version Number
- A documentation string.
*** Buffers
The only way anything can passed to or from the module is through
buffers.

The only required component when defining a buffer is the buffer-name.

**** Request Parameters
any requests to the buffer are passed through request
parameters. Make sure that all parameters are validated in the module
when passed to it.

**** Queries
Any queries that the module will accept through the buffer must be
defined when the module is defined.

*** Interface functions
The module interacts with the rest of the system by providing
functions that are called at the appropriate times, for example during
creation, reset, delete etc.
**** Creation
when a new model is created an instance of the module is defined by the
system for that model. This is when the creation function is
called. 
***** Arguments passed
Name of the module
***** Return Value
Is a datastructure that is used to store state. This data structure is
passed around when other functions in the module are called.
**** reset
We can provide two functions that get called when the model get
reset. 

One is the primary reset function and the other is the secondary reset
function. The primary reset function gets called before the values in
the instance are reset. 

The secondary reset function gets called later
**** delete
This function is called when the model is deleted, its passed the
instance of the module.
**** parameters
If a module is monitoring parameters or provides parameters then it
must provide a function for setting or getting those parameter values.

This function call is passed two arguments
- The instance of the module
- The second parameter can have two values
  - If its just a key word, then its a request for that parameter value
  - If its a cons with a key word and value its a request to set that parameter.
**** queries
If a module has one or more buffers it must provide a function for
querying them.

The arguments that would be passed to this function are 
- the instance of the module
- The name of the buffer being queried
- Query
- Value of the query to test

Every module is expected to respond to queries of state with values of
- Free
- Busy
- Error

The return value of the query can be considered to be a boolean.
**** Requests
IF a module provides buffers it *may* provide a function to handle
requests to those buffers.

The arguments that are passed to this function are 
1) The instance of the module
2) The name of the buffer
3) the chunk spec containing further details.

* Bio bike Code
** TODO Write functions that can help compare the frames
** blload 
This file is the one that loads all the knowledge bases. This is
following things that we would have to clean up.

- [X] SOAP interface for the KEGG knowledge base
- [X] Prevent loading of all the knowledge bases
  ** ai - Application instance
** Weblisten/login-procedures.lisp 
* after-new-login-actions*
Wrap up the exports in a function and put that in the list 
* Experiment
** Starting the server						     :SERVER:
1) As soon as lisp starts up type 
(force-all)
(bll)
(setq cl-user::*biowebserver* nil)
(wb:start-weblistener)
** Model Framework                                                   :MODEL:
*** Fill in all vertical clues
**** If a clue has only one solution mark it solved
*** Fill in all the horizontal clues.
**** If the solution the the horizontal solution is the only solution then mark that clue as solved.
*** For every vertical clue not marked solved
**** Check if it breaks any horizontal clue that is not marked solved
**** 
* Ideas 							      :IDEAS:
** Integrate chunks and frames. 				:DISCUSSED:
The advantages of this would be if there are tools that are developed
for frames they can be applied directly to the chunks.
* Report
** Report Todos
** Write about providing a unified interface between frames and chunks
** Reasons why frames is a good idea, reasons why other things would suck
** Write about the enviroment as it is
** Write about providing an isolated enviroment
* Code Notes
** Redisplay URL
   - call weblistener-redisplay-function with the macro
     execute-with-standard-weblistener-environment 
   - Function that gets called when the user evaluates stuff in the
     form weblistener-standard-form-response 
     - calls function make-default-repl
       - calls make-repl
* Todos
** STARTED Chapter 2
   - [-] Chapter 2 [2/5]
	 - [X] Introduction
	 - [X] The Nature of cognition
	 - [-] Approaches towards explaining cognition [1/2]
	   - [X] The cognitivist Approach [3/3]
	     - [X] Describe the cognitivist view point
	     - [X] Describe how the models are done
	     - [X] Describe the drawbacks
	   - [ ] The connectionist approach
	 - [ ] Cognitive Architectures
	 - [ ] Challenges facing cognitive architectures
* Books
** Computer supported collaborative work
*** Reading 1
**** Section 1
The first section talks about the fact that science has provided us
with the means to store ideas, consult and manipulate them at a time
we choose to. As a result ideas get extended over a life time of a
race rather than the life time of an individual. 
** Unified Theories of cognition
*** Chapter 1
**** Section 1.1.4
He defines a theory as a body of knowledge that can
1) Predict answers
2) Explain stuff
3) Prescribe controls

* The most powerful form of theory is a body
underlying mechanisms whose interactions and composition provide
answers to our questions*

In this section he tries to explain the charateristics of the theory. He explains
**** Theory gives answers and not humans
**** Theories are approximate 
because they are consist of a tradeoff between accuracy and certanity
**** Theories cumulate
That is theories are reforumulated, refined over and over again
**** Theories are things that are to be nurtured and built up.
**** Section 1.2: What are the unified theories of cognition?
He starts up by explaining what is required for a unified theory of
cognition.

Why have a unified theory of cognition?

1) Unification is the aim of science
2) Bringing all parts to bear on a behaviour
   We are trying to understand the behaviour of the mind, and since
   the mind is shaped by a number of constraints it requires a unified
   theory to bring these constraints to affect and determine the
   structure of the mind.
3) Bringing in multiple constants to bear
4) Increased rate of cumulation
5) Increased identifiability
6) Amortization of thoritical constructs
7) Open the way to applications
8) Change from discrimiative to approximate style
9) Solve the irrelevant specification problem
*** Chapter 2
**** Behaving Systems
     CLOCK: [2009-06-12 Fri 13:51]--[2009-06-12 Fri 13:52] =>  0:01
A mind can be viewed as a control system that evolved within the
organism so as to provide benefit to the organism or most importantly
for the survival of the species. 

The mind can be seen to provide response function, that is the
organism takes actions as a function of the environment. That is if
the environment is different the organism would behave in a different manner.
**** TODO Knowledge Systems
Using the language of control systems is not appropriate because it
restricts us a specific class of tasks and or a specific environment

A way to describe such behaviour is considering systems that have
knowledge and act in based on that knowledge to achieve certain goals.

According to Newell what is required by cognitive science is a concept
of knowledge that would help predict and describe the response
function for a function.

The singularly most important law about knowledge systems is that
every knowledge system acts so as to satisfy some goal.

*** Along the frontiers

** Knowledge representation and reasoning
*** knowledge					       :knowledge:definition:
    From section 1.1
    
    One way to look at it is Knowledge is a relation between the knower
    and a proposition, a proposition an an abstract entity that
    determines the truth value between two or more entities, knowledge
    can also 
Epistemology And Methodology

** Cognitive science an introduction
*** Chapter 1
**** The cognitive view
cognitive science views the human mind as a system that stories,
retrieves, transforms and transmits information. All these operations
are called information processes.
**** Some fundamental concepts
***** Information processes are purposeful and contentful
The thing here is that we need to understand the reasoning behind the
way information processes work because they help an organism make
decisions in an environment. 

The reason why this is important is that we are trying to construct a
new system that performs as the old system, therefore we have to be
certain of the manner in which these processes work.
***** Information processes are representational.
They start the section by describing how the number system is a place
value system in that the number itself is some abstract quantity
represented by a symbol.

They further go on to explain the properties of this.
1) Using a basic set of symbols and rules of combination newer symbols
   can be constructed, allowing the length of the strings to be of
   unlimited length allow us to generate an infinite number of symbols.
2) Second the basic symbols contribute to the meaning of the larger symbols.
3) Information processes that transform symbolic inputs to symbolic
   outputs can be defined in terms of the symbols. These information
   processes are called algorithms.
   
   algorithms mimics the operation in the real world they are called isomorphic.
   
***** Information proceeses can be described formally.
***** Cognitive Science is a basic science.
information processing view about cognitive science uses the above
principles to explain basic information processing capabilities.
**** Information processes can be analysed at several levels
Information has to be analysed at several levels, for example
examining an information process at a lower level
*** Chapter 2
**** The notion of cognitive architecture :COGNITIVE:ARCHITECTURE:
The prevailing view is that an intelligent system is composed of a
number of parts. A cognitive architecture refers to information
processing capacities and mechanisms of a system that are built in.

Understanding the architecture will help us "predict"(Newell) what a
system is capable of doing an why.

The most basic goal of cognitive science is to understand how the
cognitive architecture makes the most mundane human competence
possible.
**** Global view of the cognitive architecture.
The thirty thousand feet view is that inputs are received through
sensory systems, processed by a central thought system, the central
thought system then issues commands to the motor system that makes
things move around.

Input and Output Systems
------------------------

Ethe first job of the sensory system si transduction, that is
converting physical energy into electro chemical activity that can be
processed by the central system

all senseory systems are supposed to be informationally encapsulated.

Central systems
---------------
This section essentially explained why they put in what they put in
Fig 2.0

Physical symbol systems
-----------------------
Explains physical symbol systems(I really must finish reading this
paper).

Universal machines
------------------
A devise capavle of computig any function is known as a universal
machine.

The authors describe the Turing machine and explain its inadequacies,
they further explain why von neumann architectures might not work.
**** Propositional Representation
THe issue is the representation of declarative knowledge, although
using natural language seems attractive the authors use a
propositional language instead. 

The reason for this being that there is a belief that an idea in the
head is very different from its representation. For example there are
times when we know a certain concept but have difficulty expressing
it.

Propositional Form
------------------
For starters they assume that propositions are simple statements that
have a truth value.

Propositional Networks as associative networks
----------------------------------------------
Long term memory: refers to cases where a piece of memory is out of
the sphere of conciousness  and then is brought back in to the sphere
after some lenght of time.

It is shown that the propositional network for all practical purposes
can be represented as a associative network where the spread of
activation helps retain the appropriate concepts.

It is also assumed that the activation happens in parallel.

A cluster of general information nodes attached to a concept node form
a conceptual schema. Schemas abstract away details in order to allow
categorization. and further thought and action based categorization.

**** Cognitive processes, working memory and attention

Just explaing the retrieval system leaves a whole lot of issues
unexplained for example how information is processed and how is
reasoning carried out. The assumption is that all cognitive processes
are goal based.

**** The connectionist approach
***** Features
A connectionist network consists of a number of computationaially
sumple processing units that communicate with each other via
connections that are capable of only handling simple signals.

The units are not endowed with complex mathematical
transformations. The cognitive task that as network performs is
determined by the arragement of units and connections. 

Learning is perhaps one of the most feature of connectionist
research. 

Prior knowledge cannot be used in networks the netwoek is assumed not
to have any such knowledge. 
***** why is connectionist research perspective attractive

Neural plasibility
-----------------
100 step rule...as a result the brain must utilize highly parallel
algorithms and artifical neural networks can do just that.

learning via adjustable weights on connections has as high degree of
neural plausbitlity because: learning in the system is mediated
by changed in synapses.

connectionist models tend to degrade gracefully in events of
damage. which is not possible in computer programs or electronincs,
have high resistance to design because of their highly parallel
nature. 

The neural plasibility arguments are highly abstract and do not
provide evidence for connectionist models

Cognitive Plausibility:
----------------------
The chief attraction is that connectionist models are are specified in
termsa of simple mechanisms where as classical models use more complex
mechanisms(But then this provides a layer of abstraction). 

* Papers
** SOAR Comparision with rule-based systems
Knowledge in SOAR is represented as productions because of the
modularity and the simplicity of reproduction. The paper contrasts
typical rule based systems with SOAR.

*** Associate, parallel knowledge
The associative knowledge is brought to bear on the system in parallel
unlike rule based system that activate rules based on the number of
clauses that have been activated. Also to mention this more explicitly
rule based systems do not bring associative memory to bear on their
knowledge.

*** Belief maintainance
SOAR uses algorithms to maintain truths about beliefs in the world,
where as rule based systems use existing rules to maintain the
truth about beliefs.

/Read up about why is truth maintainance brittle when done via rule
based systems/

*** Preference based deliberation
is a means by which SOAR allows agents to bring in their knowledge
into the decision making process. If there is a conflict in the rules,
SOAR uses this preference knowledge to make a decision unlike rule
based systems that have a fixed means of doing so.

When a deliberation is successful it results in SOAR picking up an
operator, an operator is which consists of preconditions and
actions. Preconditions and actions, are implemented as seperate
rules, as a result there are a fewer number of total rules. Unlike RBS
where every rule represents an operator and there has to be a
permutation and combination of clauses and actions for every rule.

*** Problem space decomposition
SOAR implements automatic subgoals, which as a result leads to the
splitting up of the problem spaces. This is good because knowledge can
be applied to specific situations and we have to search a smaller area
of knowledge.

Since the problem space is split up the way it is, the agent can work
with a number of spaces in parallel which makes it very scalable.

*** Adapatation
When stuck the agent resolves the impasse by generalizing and
summarizing the knowledge.

** SOAR: An Architecture for general intelligence

*** Abstract
The abstract is very interesting it talks about the defintion a
cognitive architecture. A cognitive architecture is a system that
should be capable of demonstrating intelligence. The idea is to
provide a structure with in which various cognitive tasks can be
demonstrated.

Unlike ACT* the predecessor of ACT-R, SOAR as such though intended for
the problem of cognitive architectures did not have a theory behind it
like ACT-R

** Beyond the chalk board: Computer support for collaboration and problem solving in meetings
*** Introduction
    People tend to use objects like chalk boards in meetings despite
    the advangates provided by the computer. 

The most important things in this paper are the research questions.

1) What are the things required to make computers an appropriate tool
   for collaborative work

2) To what extent do work the current work practices compare with the
   settings. 

3) Does abstracting a tool make it portable across groups?
   -- Interesting question...because if you abstract out ACT-R would
   it make it portable across groups that work with SOAR?

4) How structure should we allow in these tools?

** A Networked environment for computer supported co-operative work
A co-operative work environment supports 
- decision making 
- computerized conferencing
- multimedia document processing
- integration with online information services.

Facilities needed to support group processes such as
- Information exchange
- Data Exchanged
- voting
- altenatives analysis
- Monitoring and controlling of its activities

Types of computer supported application work
- synchronous
- async
  
Application areas for computer supported work
- Synergy Development
  - Access to a large number of people from a number of
    different areas across geographical locations
  - Advantages 
    - avoid redundancies
    - more creative and complete solutions
    - Easy access to expertise
    - accumalated answers to simlar questions
- Electronic meeting and group decisions
  - Brain storming etc,
- Office managgement systems
  - Calendar
  - scheduling
- Education
  - Effective alternative to facet to face ommunication
    - Check paper "Virtual Class room" S. R. Hiltz
  - Makes the process of disemminating instructional methods easier
- Support horizontal distributed processing
  - achieved through support of remote operations on remote data
  - Environmental independence for users
** BioBike
*** Goals
**** biologists are quick to accept tools in biology but not in bioinformatics.
**** Combining data requires tonnes of time and is painstaking as there is a lot of searching involved.
***** As a result they have to use computer programmers to interface with the computer for them.
**** Biolingua provides biologists witha  hands on capability by allowing them to work with large data sets in a familiar language.
**** Guiding Principles
***** All required data and knowleode is accessible through a common framework.
***** The systen implements an efficient general purpose language with bioinformatic related functionality.
***** The environment is highly interactive.
***** State of the art system biology tools that provide causal reasoning integrated into the system.
***** The environment provides tools for collaboration and announcing results and models
*** Implementation
**** Conceptual Layers
***** The base knowledge layer
Represents basic concepts such as organism, genome, gene etc.
***** The programming layer
provides abstractions to combine the primitives defined in the layer
below
***** Task specific interface layer
provides specific interactive graphical interfaces for public use.
***** The Collaboration layer
Wiki
** Cognitive Modelling, Symbolic
   Symbolic cognitive are models of human cognition taking the form of
computer programs. The idea is a cognitive modelling explains how a
computation process can be explained by means of computational
primitives.

Cognitive modelling tries to answer questions in cognitive psychology
and draws on methods from Artificial intelligence. The basis of the
cognitive modelling is that the mind does what it does in part using
computational processes and if we can model those out that would give
us insight into the cognitive architecture of the human brain.

A cognitive model is considered a symbolic cognitive model if it
satisfies the Physical symbol system hypothesis as suggested by Simon
Newell. Which is essentially a restatement of the (church-turing
hypothesis), which states that symbolic computation is the basis for
complex cognition. More precisely 

The requirement is that the system be capable of manipulating and
composing symbols and symbol structures which is a way of representing
the physical process that manipulate patterns.

The amount of connectionism in cognitive modelling is a matter of
debate. Most of the debate is about whether a cognitive system can or
cannot manipulate and create structures.

Specifically Fodor and Pylyshyn state that for any cognitive modelling
system to have two properties
  - Productivity: the ability to produce novel structures
  - Systematicity: That is there should be an intrinsic connection
    between what is produced and the ability to comprehend that.

Why are Productions system good?

Yeah true they do provide a flexible means of representing cognition,
but they why are is it good, Read the newell 1973 paper

Recent work involves approaches of building and working with Cognitive
Architectures. The idea is that we know for certain that computers do
not provide a good representation of the process running in our heads
so what we are supposed to simulate that and then model on top of
that.

There are tonnes of architectures taht do that for example ACT-R,
SOAR, Epic and EPAM
** Physical Symbol Systems
*** Constraints on mind.
The study of the nature of the mind can be considered as a constraint
solving problem. He then lists out 13 constraints that he considers
are important. He also does mention that not all these constraints are
isolated.
*** SS a paradigmatic system
the system consists of memory a set of operators a control, an input
and an output. Its inputs are objects in certain locations; its
outputs are modification or the creation of the objects in certain
locations.

The memory is composed of symbol structures, the term expression us
used interchangeably with symbol structure. A set of abstract symbols
are used to define symbol structures. Each symbol structure is
assigned a type and has a role. 

The behavior of the system is governed by control. It also has a
symbol for the active expression, the behaviour of the control is to
continually interpret whatever expression is active.

He then summarises the working of the physical symbol system which in
essense can be described essentially as a lisp interpreter.
*** Universality
centrail to universality is the flexibility of behavior but then that
does not imply that the output of the function can be any output
whatsoever. The output has to be a function of the input.

The flexibility that is a part of universality is required because in
the real world the agent might come up against situtation that is not
convienent for the system.

The issues when endowning a system with flexibility are
1) Machines are prisoners of their own domain and they cannot interact
   with the outside world
2) There are limits imposed by the world on the system
3) The only means by which a system would be able to produce more than
   one input is by separating the inputs into two parts
   a) The instruction 
   b) The data
4) Not all functions are computable.

To prove universality, you have to prove that the system can mimic the
behavior of a system in the big class of universal systems.

** Integrated cognitive architectures A Survey
*** Introduction
**** Early Survey: 1994
***** Surveyed 12 architectures
***** Based on
****** Properties of architectures
****** capabilities of agents
****** Environmental considerations
****** Genrality
****** Psychological Validity
****** Efficiency
***** Atlantis
***** Theo
***** Prodigy
***** ICARUS
***** RALPH-MEA
***** Entropy Reduction Engine
**** This paper compares
***** ACT-R
***** BDI
***** ICARUS
***** Soar
***** Subsumption
***** CLARION
*** Review of Six architectures
    This paper essentially does the following
For every cognitive architecture it describes the architecture and the functions

It later compares architectures based on 
1) Perception
2) Memory
3) Goals
4) Problem solving
5) Planning
6) Reasoning and Inference
7) Learning
** Towards Robust Cognitive Architecture for autonmous mobile robots
** Newell test for a theory of cognition
*** Introduction
**** Newells' Criteria
***** Cognition as a function of environment
Newell recognized the ability of humans to perform a wide variety of
cognitive tasks with out the need for evolutionary specialization and
tried to associate it with the universal computability of the turing
machine. But unlike the turing machine people did not have infinite
memory and slipped up. 
***** Real time performance
The idea here was that how fast a system is able to perform its
processes. 
***** Adaptive Behaviour
** History of cognitive science
Based on Noam Chomsky's "How is that humans whose contacts with the
world are brief and personal are able to know as much as they know.

Cognitive science tries to answer two questions

1) What are the structures of knowledge and how do processes work on
   them in the way they do, the approaches they use to obtain inferences.
2) The second question is about the system that actually implements
   cognition.

*** Rationalist approach

This led of a way of thinking called the rationalist approach
This followed the most intutive method

1) Define knowledge
2) Identify cognitive structures
3) And use the above definitions to get to the nature of the mind

For example Descartes used the following strategy
1) Define knowledge and identify the cognitive capability and then to
   the nature of the mind.

This approach is characterized by
1) A well designed top down analysis, a method of theorizing at
   individual levels
** A survey of artificial cognitive systems :David vernon
*** Different approaches to cognition
**** Cognitivist
***** Views human cognition from an information processing angle
**** Emergent
#I need to write about the nature of cogniton from the emergent perspective.
***** View human cogniton from an angle that is symbolic, rational, structured and algorithmic
***** a system becomes viable in its environment
***** It does so by the process of self organization.
***** Connectionist models
      Rely of non symbolic processing of activation patterns rather
      than logical rules. (49)
      The original motivation for the work on emergent systems was due
      to the inability of some researcher who believed that cogniton
      was sequential, atemporal and localized. But then this itself
      does not distinguish cognitivist systems from connectionist
      systems because, the state of the connectionist system is tied
      to the history of its transformations which have occured due to
      its interaction with its environment. 

      Secondly connectionist systems attribute meaning to be the
      global state of the system, it is defined as the state that is
      observable to the viewer of the system. 

      

**** Points of difference
***** Computational Operation
****** Cognitivistise rule based manipulation
****** Use processes of self organization, self production, self-maintainance and self-development
***** Representational Framework




       
